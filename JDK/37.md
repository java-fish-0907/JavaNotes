


## JNI

JNI即Java Native Interface，它能在Java层实现对本地方法的调用，一般本地的实现语言主要是C/C++，其实从虚拟机层面来看JNI挺好理解，JVM主要使用C/C++ 和少量汇编编写，在执行Java字节码时如果遇到有某个方法标明为Native的则从JVM中找到对应的C/C++函数，一般本地方法对应的函数会被注册到JVM中。

使用JNI能让Java与本地语言交互，但一般也意味着丧失了跨平台性，而有些场合会使用。比如标准的Java特性不符合你的需求时，比如在性能要求很高的某段逻辑。

## 从一个例子说起


```js 
package com.seaboat.bytecode;
    
        public class ByteCodeEncryptor {
          static{
            System.loadLibrary("ByteCodeEncryptor");
          }
    
          public native static byte[] encrypt(byte[] text);
    
        }
```


```js 
/* DO NOT EDIT THIS FILE - it is machine generated */
        #include <jni.h>
        /* Header for class com_seaboat_bytecode_ByteCodeEncryptor */
    
        #ifndef _Included_com_seaboat_bytecode_ByteCodeEncryptor
        #define _Included_com_seaboat_bytecode_ByteCodeEncryptor
        #ifdef __cplusplus
        extern "C" {
        #endif
        /*
         * Class:     com_seaboat_bytecode_ByteCodeEncryptor
         * Method:    encrypt
         * Signature: ([B)[B
         */
        JNIEXPORT jbyteArray JNICALL Java_com_seaboat_bytecode_ByteCodeEncryptor_encrypt
          (JNIEnv *, jclass, jbyteArray);
    
        #ifdef __cplusplus
        }
        #endif
        #endif
```


```js 
#include "com_seaboat_bytecode_ByteCodeEncryptor.h"
        #include "jni.h"
    
        void encode(char *str)
        {
            unsigned int m = strlen(str);
            for (int i = 0; i < m; i++)
            {
                str[i] = str[i]+4;
            }
    
        }
    
        extern"C" JNIEXPORT jbyteArray JNICALL
        Java_com_seaboat_bytecode_ByteCodeEncryptor_encrypt(JNIEnv * env, jclass cla,jbyteArray text)
        {
            char* dst = (char*)env->GetByteArrayElements(text, 0);
            encode(dst);
            env->SetByteArrayRegion(text, 0, strlen(dst), (jbyte *)dst);
            return text;
        }
```


```js 
cl /EHsc -ID:\Java\jdk1.8.0_73\include\ -ID:\Java\jdk1.8.0_73\include\win32 -LD com_seaboat_bytecode_ByteCodeEncryptor.cpp -FeByteCodeEncryptor.dll
```

## 怎么加载动态库

Java层需要调用`System.loadLibrary`去加载动态库，而它其实就是通过`ClassLoader`的`loadLibrary`方法来加载，加载的大致逻辑为：

对应着`ClassLoader.c`的***Java_java_lang_ClassLoader_00024NativeLibrary_load***函数，因为NativeLibrary在Java层的ClassLoader的子类，所以其中包含一串数字`00024`，即表示美元符号。该函数最重要的一步是调了`JVM_LoadLibrary`函数，该函数如下，核心的一步是`os::dll_load`，它会根据不同的操作系统做不同的处理。

```js 
JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
          //%note jvm_ct
          JVMWrapper2("JVM_LoadLibrary (%s)", name);
          char ebuf[1024];
          void *load_result;
          {
            ThreadToNativeFromVM ttnfvm(thread);
            load_result = os::dll_load(name, ebuf, sizeof ebuf);
          }
          if (load_result == NULL) {
            char msg[1024];
            jio_snprintf(msg, sizeof msg, "%s: %s", name, ebuf);
            // Since 'ebuf' may contain a string encoded using
            // platform encoding scheme, we need to pass
            // Exceptions::unsafe_to_utf8 to the new_exception method
            // as the last argument. See bug 6367357.
            Handle h_exception =
              Exceptions::new_exception(thread,
                                        vmSymbols::java_lang_UnsatisfiedLinkError(),
                                        msg, Exceptions::unsafe_to_utf8);
    
            THROW_HANDLE_0(h_exception);
          }
          return load_result;
        JVM_END
```

看一个图，它包含了`linux`、`solaris`、`windows`三大类型操作系统的处理，下面分别看看不同操作系统如何处理。

![202105041936296381.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/JDK/299ae2ae-1c61-47f1-a298-53c2de5b0040.png)

另外，我们注意到Java层不必指定动态库的后缀，这个留给JVM去解决，它会根据不同操作系统添加不同的后缀，这个逻辑由`System.c`的`Java_java_lang_System_mapLibraryName`函数实现，它会有如下两个后缀。

```js 
#define JNI_LIB_SUFFIX ".so"
    
        #define JNI_LIB_SUFFIX ".dll"
```

## 字节码

对于字节码，它是Java执行时的指令，其实想一下就能想到本地方法要在执行时区别于Java层的调用，所以必须要有一个flag来标识本地方法，那咱们用javap来看看上面包含本地方法的class会有什么标识，可以看到存在一个`ACC_NATIVE`，有了它就可以在执行时调用C/C++函数了。

```js 
public static native byte[] encrypt(byte[]);
            descriptor: ([B)[B
            flags: ACC_PUBLIC, ACC_STATIC, ACC_NATIVE
```
  
版权声明：本文为站长转载&整理，本站不享有版权，版权归原作者所有，[版权声明](https://gitee.com/hezhiyuan007/java-notes/raw/master/disclaimer.md)。




原文作者：超人汪小建(seaboat) 原文地址：https://blog.csdn.net/wangyangzhizhou/column/info/16032