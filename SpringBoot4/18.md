


![202112251628490931.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/SpringBoot4/12fa733d-1ef0-4700-858d-d04e0f1c30f2.png)

## 前言

开发这么多年，肯定还有不少小伙伴搞不清各种类型的参数是如何传递的，很多同学都是拿来即用，复制粘贴一把撸，遇到问题还是一脸懵逼。

## 姿势

学习参数传递的正确姿势，先说怎么做，再说为什么，本质上还是复制粘贴一把撸，问题是你想问不想问为什么！

## 传递

#### 用户登录

前端代码：

```js 
var param = {
        "username": "admin",
        "password": "admin"
    }
    $.ajax({
        url: "/sys/login",
        data: param,
        type: "post",
        dataType: "json",
        success: function(data) {
    
        }
    });
```

后端代码：


```js 
@RestController
    @RequestMapping("/sys")
    public class LoginController {
    
        private static final Logger logger = LoggerFactory.getLogger(LoginController.class);
    
        /**
         * 登录
         */
        @PostMapping("/login")
        public Result login(String username, String password){
            logger.info("用户登录"+username);
            //业务逻辑
            return Result.ok("登录成功");
        }
    }
```

当然，你也可以这么实现，`@RequestParam(value="username", required=true)` ，`required` 默认为 `true`，如果前台不传递此参数，后台会报错。如果设置为 `false`，如果不传，默认为 `null`。


```js 
/**
      * 登录
      * https://blog.52itstyle.vip
      */
    @PostMapping("/login")
    public Result login(@RequestParam(value="username", required=true) String username,
                        @RequestParam(value="password", required=true) String password){
        logger.info("用户登录"+username);
        //业务逻辑
        return Result.ok("登录成功");
    }
```

#### 用户注册

前端代码，提交方式与登录基本保持一致。

后端代码：

用一个对象来接收前台参数，一般后端有对应的实体类。

```js 
/**
      * 注册
      * https://blog.52itstyle.vip
      */
    @PostMapping("/register")
    public Result register(SysUser user){
        logger.info("{}，用户注册",user.getUsername());
        //业务逻辑
        return Result.ok("注册成功");
    }
```

#### 多参数无实体一

前端代码：

```js 
var param = {
        "title": "爪哇笔记",
        "content": "一个有趣的公众号",
        "author": "小柒2012"
    }
    param = JSON.stringify(param);
    $.ajax({
        url: "/sys/multiParameter",
        data: param,
        type: "post",
        contentType: "application/json",
        dataType: "json",
        success: function(data) {
    
        }
    });
```

后端实现：


```js 
/**
      * 多参数
      * https://blog.52itstyle.vip
      */
    @PostMapping("/multiParameter")
    public Result register(@RequestBody Map<String,Object> map){
        logger.info("多参数传递:{},{}",map.get("title"),map.get("content"));
        //业务逻辑
        return Result.ok("接收多参数成功");
    }
```

#### 多参数无实体二

前端代码：

```js 
var param = {
        "title": "爪哇笔记",
        "content": "一个有趣的公众号",
        "author": "小柒2012"
    }
    $.ajax({
        url: "/sys/multiParameter",
        data: param,
        type: "post",
        dataType: "json",
        success: function(data) {
    
        }
    });
```

后端实现：


```js 
/**
      * 多参数
      * https://blog.52itstyle.vip
      */
    @PostMapping("/multiParameter")
    public Result register(@RequestParam Map<String,Object> map){
        logger.info("多参数传递:{},{}",map.get("title"),map.get("content"));
        //业务逻辑
        return Result.ok("接收多参数成功");
    }
```

#### 传递数组

前端代码：

```js 
var param = {
        "ids": [1, 2, 3]
    }
    $.ajax({
        url: "/sys/array",
        data: param,
        type: "post",
        dataType: "json",
        success: function(data) {
    
        }
    });
```

后端实现：


```js 
/**
      * 数组
      * https://blog.52itstyle.vip
      */
    @PostMapping("array")
    public Result array(@RequestParam(value = "ids[]") Integer[] ids) {
        logger.info("数据{}", Arrays.asList(ids));
        //业务逻辑
        return Result.ok();
    }
```

#### 传递集合

前端代码与传递数组保持一致。

后端实现：

```js 
/**
      * 集合
      * https://blog.52itstyle.vip
      */
    @PostMapping("array")
    public Result array(@RequestParam(value = "ids[]") List<Integer> ids) {
        logger.info("数据{}", ids.toString());
        //业务逻辑
        return Result.ok();
    }
```

#### 传递集合实体对象

比如，后端想接收一个实体对象集合 `List<SysUser>`

前端代码：

```js 
var list = [];
    list.push({
        "username": "小柒2012",
        "mobile": "17762288888"
    });
    list.push({
        "username": "小柒2013",
        "mobile": "17762289999"
    });
    $.ajax({
        url: "/sys/listUser",
        data: JSON.stringify(list),
        type: "post",
        contentType: "application/json",
        dataType: "json",
        success: function(data) {
    
        }
    });
```

后端代码：


```js 
/**
      * 爪哇笔记
      * https://blog.52itstyle.vip
      */
    @PostMapping("listUser")
    public Result listUser(@RequestBody List<SysUser> list) {
       logger.info("数据{}", list.size());
       list.forEach(user->{
          //输出实体对象
          System.out.println(user.getUsername());
       });
       //业务逻辑
       return Result.ok();
    }
```

#### 传递集合实体对象一对多

比如，一个用户有多个角色 `List<SysRole> roleList`

前端代码：

```js 
var roleList = [];
    roleList.push({
        "roleSign": "admin",
        "roleName": "管理员"
    });
    roleList.push({
        "roleSign": "user",
        "roleName": "普通用户"
    });
    var list = [];
    var user = {
        "username": "小柒2012",
        "mobile": "17762288888"
    };
    user.roleList = roleList;
    list.push(user);
    $.ajax({
        url: "/sys/listUserRole",
        data: JSON.stringify(list),
        type: "post",
        contentType: "application/json",
        dataType: "json",
        success: function(data) {
    
        }
    });
```

后端实现：


```js 
/**
      * 爪哇笔记
      * https://blog.52itstyle.vip
      */
    @PostMapping("listUserRole")
    public Result listUserRole(@RequestBody List<SysUser> list) {
        logger.info("数据{}", list.size());
        list.forEach(user->{
            List<SysRole> roleList = user.getRoleList();
            roleList.forEach(role->{
              System.out.println(role.getRoleName());
            });
        });
        return Result.ok();
    }
```

#### 炒鸡复杂

传输对象有实体，有集合，有各种类型的数据，这时候最简单的方式就是传递 `Key-Value` 结构的 `JSON` 字符串，后台 `Map` 类型接收，然后通过`FastJson`的 `JSON.parseObject()` 和 `JSON.parseArray()` 方法转化为对应的实体或者集合。

```js 
String user = parseMap.get("user").toString();
     SysUser sysUser = JSON.parseObject(user,SysUser.class);
     String contractClause = parseMap.get("rules").toString();
     List<Rule> ruleList = JSON.parseArray(contractClause,Rule.class);
```

#### RESTful 风格

比如，访问某篇文章：

```js 
/**
      * 爪哇笔记
      * https://blog.52itstyle.vip
      */
    @GetMapping("article/{id}")
    public void article(@PathVariable("id") String id) {
        logger.info("文章{}",id);
        //业务逻辑
    }
```

## 原则

记住一下几点：

## 扩展

在以上只涉及了两种 `contentType` 类型，其实还有两种常见的类型：

#### 
```js 
multipart/form-data
```

一般用于表单文件上传，必须让 form 的 enctype 等于这个值。

```js 
<form action="/upload" method="post" enctype="multipart/form-data">
      <input type="text" name="description" value="爪哇笔记，一个神奇的公众号">
      <input type="file" name="myFile">
      <button type="submit">Submit</button>
    </form>
```

#### 
```js 
text/xml
```

做过微信支付的小伙伴一定会知道，微信就喜欢用这种方式，去年还发生过 `XXE` 漏洞，在解析XML文档时，解析器通过 ENTITY 扩展的功能，读取本地受保护的文件，并且使用扩展功能将受保护的文件发送到远程地址。

## 小结

不敢说是最完整的传参方案，但绝对敢保证是最正确的，因为所有的传参方式都经过 360° 官方检验。
版权声明：本文为站长转载&整理，本站不享有版权，版权归原作者所有，[版权声明](https://gitee.com/hezhiyuan007/java-notes/raw/master/disclaimer.md)。




原文作者：小柒 原文地址：https://blog.52itstyle.vip/category/springBoot/