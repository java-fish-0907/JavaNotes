


和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。

Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。

使用Commons Logging只需要和两个类打交道，并且只有两步：

第一步，通过`LogFactory`获取`Log`类的实例； 第二步，使用`Log`实例的方法打日志。

示例代码如下：

```js 
import org.apache.commons.logging.Log;
    import org.apache.commons.logging.LogFactory;
    ----
    public class Main {
        public static void main(String[] args) {
            Log log = LogFactory.getLog(Main.class);
            log.info("start...");
            log.warn("end.");
        }
    }
```

运行上述代码，肯定会得到编译错误，类似`error: package org.apache.commons.logging does not exist`（找不到`org.apache.commons.logging`这个包）。因为Commons Logging是一个第三方提供的库，所以，必须先把它[下载](https://commons.apache.org/proper/commons-logging/download_logging.cgi)下来。下载后，解压，找到`commons-logging-1.2.jar`这个文件，再把Java源码`Main.java`放到一个目录下，例如`work`目录：


```js 
work
    │
    ├─ commons-logging-1.2.jar
    │
    └─ Main.java
```

然后用`javac`编译`Main.java`，编译的时候要指定`classpath`，不然编译器找不到我们引用的`org.apache.commons.logging`包。编译命令如下：


```js 
javac -cp commons-logging-1.2.jar Main.java
```

如果编译成功，那么当前目录下就会多出一个`Main.class`文件：


```js 
work
    │
    ├─ commons-logging-1.2.jar
    │
    ├─ Main.java
    │
    └─ Main.class
```

现在可以执行这个`Main.class`，使用`java`命令，也必须指定`classpath`，命令如下：


```js 
java -cp .;commons-logging-1.2.jar Main
```

注意到传入的`classpath`有两部分：一个是`.`，一个是`commons-logging-1.2.jar`，用`;`分割。`.`表示当前目录，如果没有这个`.`，JVM不会在当前目录搜索`Main.class`，就会报错。

如果在Linux或macOS下运行，注意`classpath`的分隔符不是`;`，而是`:`：

```js 
java -cp .:commons-logging-1.2.jar Main
```

运行结果如下：


```js 
Mar 02, 2019 7:15:31 PM Main main
    INFO: start...
    Mar 02, 2019 7:15:31 PM Main main
    WARNING: end.
```

Commons Logging定义了6个日志级别：

默认级别是`INFO`。

使用Commons Logging时，如果在静态方法中引用`Log`，通常直接定义一个静态类型变量：

```js 
// 在静态方法中引用Log:
    public class Main {
        static final Log log = LogFactory.getLog(Main.class);
    
        static void foo() {
            log.info("foo");
        }
    }
```

在实例方法中引用`Log`，通常定义一个实例变量：


```js 
// 在实例方法中引用Log:
    public class Person {
        protected final Log log = LogFactory.getLog(getClass());
    
        void foo() {
            log.info("foo");
        }
    }
```

注意到实例变量log的获取方式是`LogFactory.getLog(getClass())`，虽然也可以用`LogFactory.getLog(Person.class)`，但是前一种方式有个非常大的好处，就是子类可以直接使用该`log`实例。例如：


```js 
// 在子类中使用父类实例化的log:
    public class Student extends Person {
        void bar() {
            log.info("bar");
        }
    }
```

由于Java类的动态特性，子类获取的`log`字段实际上相当于`LogFactory.getLog(Student.class)`，但却是从父类继承而来，并且无需改动代码。

此外，Commons Logging的日志方法，例如`info()`，除了标准的`info(String)`外，还提供了一个非常有用的重载方法：`info(String, Throwable)`，这使得记录异常更加简单：

```js 
try {
        ...
    } catch (Exception e) {
        log.error("got exception!", e);
    }
```

使用`log.error(String, Throwable)`打印异常。

[Commons Logging练习](https://gitee.com/liaoxuefeng/learn-java/raw/master/practices/Java%E6%95%99%E7%A8%8B/30.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.1255943543190176/70.%E4%BD%BF%E7%94%A8Commons%20Logging.1264738932870688/logging-commons.zip)

Commons Logging是使用最广泛的日志模块；

Commons Logging的API非常简单；

Commons Logging可以自动检测并使用其他日志模块。
版权声明：本文为站长转载&整理，本站不享有版权，版权归原作者所有，[版权声明](https://gitee.com/hezhiyuan007/java-notes/raw/master/disclaimer.md)。




原文作者：廖雪峰的网站 原文地址：https://www.liaoxuefeng.com/