


Java编译器对`String`做了特殊处理，使得我们可以直接用`+`拼接字符串。

考察下面的循环代码：

```js 
String s = "";
    for (int i = 0; i < 1000; i++) {
        s = s + "," + i;
    }
```

虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。

为了能高效拼接字符串，Java标准库提供了`StringBuilder`，它是一个可变对象，可以预分配缓冲区，这样，往`StringBuilder`中新增字符时，不会创建新的临时对象：

```js 
StringBuilder sb = new StringBuilder(1024);
    for (int i = 0; i < 1000; i++) {
        sb.append(',');
        sb.append(i);
    }
    String s = sb.toString();
```

`StringBuilder`还可以进行链式操作：


```js 
// 链式操作
    ----
    public class Main {
        public static void main(String[] args) {
            var sb = new StringBuilder(1024);
            sb.append("Mr ")
              .append("Bob")
              .append("!")
              .insert(0, "Hello, ");
            System.out.println(sb.toString());
        }
    }
```

如果我们查看`StringBuilder`的源码，可以发现，进行链式操作的关键是，定义的`append()`方法会返回`this`，这样，就可以不断调用自身的其他方法。

仿照`StringBuilder`，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器：

```js 
// 链式操作
    ----
    public class Main {
        public static void main(String[] args) {
            Adder adder = new Adder();
            adder.add(3)
                 .add(5)
                 .inc()
                 .add(10);
            System.out.println(adder.value());
        }
    }
    
    class Adder {
        private int sum = 0;
    
        public Adder add(int n) {
            sum += n;
            return this;
        }
    
        public Adder inc() {
            sum ++;
            return this;
        }
    
        public int value() {
            return sum;
        }
    }
```

注意：对于普通的字符串`+`操作，并不需要我们将其改写为`StringBuilder`，因为Java编译器在编译时就自动把多个连续的`+`操作编码为`StringConcatFactory`的操作。在运行期，`StringConcatFactory`会自动把字符串连接操作优化为数组复制或者`StringBuilder`操作。

你可能还听说过`StringBuffer`，这是Java早期的一个`StringBuilder`的线程安全版本，它通过同步来保证多个线程操作`StringBuffer`也是安全的，但是同步会带来执行速度的下降。

`StringBuilder`和`StringBuffer`接口完全相同，现在完全没有必要使用`StringBuffer`。

请使用`StringBuilder`构造一个`INSERT`语句：

```js 
public class Main {
        public static void main(String[] args) {
            String[] fields = { "name", "position", "salary" };
            String table = "employee";
            String insert = buildInsertSql(table, fields);
            System.out.println(insert);
            String s = "INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)";
            System.out.println(s.equals(insert) ? "测试成功" : "测试失败");
        }
    ----
        static String buildInsertSql(String table, String[] fields) {
            // TODO:
            return "";
        }
    ----
    }
```

[StringBuilder练习](https://gitee.com/liaoxuefeng/learn-java/raw/master/practices/Java%E6%95%99%E7%A8%8B/20.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.1255943520012800/20.Java%E6%A0%B8%E5%BF%83%E7%B1%BB.1260576204194144/20.StringBuilder.1260471862687712/core-stringbuilder.zip)

`StringBuilder`是可变对象，用来高效拼接字符串；

`StringBuilder`可以支持链式操作，实现链式操作的关键是返回实例本身；

`StringBuffer`是`StringBuilder`的线程安全版本，现在很少使用。
版权声明：本文为站长转载&整理，本站不享有版权，版权归原作者所有，[版权声明](https://gitee.com/hezhiyuan007/java-notes/raw/master/disclaimer.md)。




原文作者：廖雪峰的网站 原文地址：https://www.liaoxuefeng.com/