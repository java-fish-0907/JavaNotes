


当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个`try ... catch`被捕获为止：

```js 
// exception
    ----
    public class Main {
        public static void main(String[] args) {
            try {
                process1();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    
        static void process1() {
            process2();
        }
    
        static void process2() {
            Integer.parseInt(null); // 会抛出NumberFormatException
        }
    }
```

通过`printStackTrace()`可以打印出方法的调用栈，类似：


```js 
java.lang.NumberFormatException: null
        at java.base/java.lang.Integer.parseInt(Integer.java:614)
        at java.base/java.lang.Integer.parseInt(Integer.java:770)
        at Main.process2(Main.java:16)
        at Main.process1(Main.java:12)
        at Main.main(Main.java:5)
```

`printStackTrace()`对于调试错误非常有用，上述信息表示：`NumberFormatException`是在`java.lang.Integer.parseInt`方法中被抛出的，从下往上看，调用层次依次是：

查看`Integer.java`源码可知，抛出异常的方法代码如下：

```js 
public static int parseInt(String s, int radix) throws NumberFormatException {
        if (s == null) {
            throw new NumberFormatException("null");
        }
        ...
    }
```

并且，每层调用均给出了源代码的行号，可直接定位。

当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。

如何抛出异常？参考`Integer.parseInt()`方法，抛出异常分两步：

下面是一个例子：

```js 
void process2(String s) {
        if (s==null) {
            NullPointerException e = new NullPointerException();
            throw e;
        }
    }
```

实际上，绝大部分抛出异常的代码都会合并写成一行：


```js 
void process2(String s) {
        if (s==null) {
            throw new NullPointerException();
        }
    }
```

如果一个方法捕获了某个异常后，又在`catch`子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：


```js 
void process1(String s) {
        try {
            process2();
        } catch (NullPointerException e) {
            throw new IllegalArgumentException();
        }
    }
    
    void process2(String s) {
        if (s==null) {
            throw new NullPointerException();
        }
    }
```

当`process2()`抛出`NullPointerException`后，被`process1()`捕获，然后抛出`IllegalArgumentException()`。

如果在`main()`中捕获`IllegalArgumentException`，我们看看打印的异常栈：

```js 
// exception
    ----
    public class Main {
        public static void main(String[] args) {
            try {
                process1();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    
        static void process1() {
            try {
                process2();
            } catch (NullPointerException e) {
                throw new IllegalArgumentException();
            }
        }
    
        static void process2() {
            throw new NullPointerException();
        }
    }
```

打印出的异常栈类似：


```js 
java.lang.IllegalArgumentException
        at Main.process1(Main.java:15)
        at Main.main(Main.java:5)
```

这说明新的异常丢失了原始异常信息，我们已经看不到原始异常`NullPointerException`的信息了。

为了能追踪到完整的异常栈，在构造异常的时候，把原始的`Exception`实例传进去，新的`Exception`就可以持有原始`Exception`信息。对上述代码改进如下：

```js 
// exception
    ----
    public class Main {
        public static void main(String[] args) {
            try {
                process1();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    
        static void process1() {
            try {
                process2();
            } catch (NullPointerException e) {
                throw new IllegalArgumentException(e);
            }
        }
    
        static void process2() {
            throw new NullPointerException();
        }
    }
```

运行上述代码，打印出的异常栈类似：


```js 
java.lang.IllegalArgumentException: java.lang.NullPointerException
        at Main.process1(Main.java:15)
        at Main.main(Main.java:5)
    Caused by: java.lang.NullPointerException
        at Main.process2(Main.java:20)
        at Main.process1(Main.java:13)
```

注意到`Caused by: Xxx`，说明捕获的`IllegalArgumentException`并不是造成问题的根源，根源在于`NullPointerException`，是在`Main.process2()`方法抛出的。

在代码中获取原始异常可以使用`Throwable.getCause()`方法。如果返回`null`，说明已经是“根异常”了。

有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。

```js 
捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！
```

如果我们在`try`或者`catch`语句块中抛出异常，`finally`语句是否会执行？例如：


```js 
// exception
    ----
    public class Main {
        public static void main(String[] args) {
            try {
                Integer.parseInt("abc");
            } catch (Exception e) {
                System.out.println("catched");
                throw new RuntimeException(e);
            } finally {
                System.out.println("finally");
            }
        }
    }
```

上述代码执行结果如下：


```js 
catched
    finally
    Exception in thread "main" java.lang.RuntimeException: java.lang.NumberFormatException: For input string: "abc"
        at Main.main(Main.java:8)
    Caused by: java.lang.NumberFormatException: For input string: "abc"
        at ...
```

第一行打印了`catched`，说明进入了`catch`语句块。第二行打印了`finally`，说明执行了`finally`语句块。

因此，在`catch`中抛出异常，不会影响`finally`的执行。JVM会先执行`finally`，然后抛出异常。

如果在执行`finally`语句时抛出异常，那么，`catch`语句的异常还能否继续抛出？例如：

```js 
// exception
    ----
    public class Main {
        public static void main(String[] args) {
            try {
                Integer.parseInt("abc");
            } catch (Exception e) {
                System.out.println("catched");
                throw new RuntimeException(e);
            } finally {
                System.out.println("finally");
                throw new IllegalArgumentException();
            }
        }
    }
```

执行上述代码，发现异常信息如下：


```js 
catched
    finally
    Exception in thread "main" java.lang.IllegalArgumentException
        at Main.main(Main.java:11)
```

这说明`finally`抛出异常后，原来在`catch`中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。

在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用`origin`变量保存原始异常，然后调用`Throwable.addSuppressed()`，把原始异常添加进来，最后在`finally`抛出：

```js 
// exception
    ----
    public class Main {
        public static void main(String[] args) throws Exception {
            Exception origin = null;
            try {
                System.out.println(Integer.parseInt("abc"));
            } catch (Exception e) {
                origin = e;
                throw e;
            } finally {
                Exception e = new IllegalArgumentException();
                if (origin != null) {
                    e.addSuppressed(origin);
                }
                throw e;
            }
        }
    }
```

当`catch`和`finally`都抛出了异常时，虽然`catch`的异常被屏蔽了，但是，`finally`抛出的异常仍然包含了它：


```js 
Exception in thread "main" java.lang.IllegalArgumentException
        at Main.main(Main.java:11)
    Suppressed: java.lang.NumberFormatException: For input string: "abc"
        at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
        at java.base/java.lang.Integer.parseInt(Integer.java:652)
        at java.base/java.lang.Integer.parseInt(Integer.java:770)
        at Main.main(Main.java:6)
```

通过`Throwable.getSuppressed()`可以获取所有的`Suppressed Exception`。

绝大多数情况下，在`finally`中不要抛出异常。因此，我们通常不需要关心`Suppressed Exception`。

异常打印的详细的栈信息是找出问题的关键，许多初学者在提问时只贴代码，不贴异常，相当于只报案不给线索，福尔摩斯也无能为力。

![202104152253_1.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/JavaBasic3/1df9d27e-d5e3-4412-9695-f180a8da78d9.png)

还有的童鞋只贴部分异常信息，最关键的`Caused by: xxx`给省略了，这都属于不正确的提问方式，得改。

如果传入的参数为负，则抛出`IllegalArgumentException`。

[抛出异常练习](https://gitee.com/liaoxuefeng/learn-java/raw/master/practices/Java%E6%95%99%E7%A8%8B/30.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.1255943543190176/30.%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8.1264738764506656/exception-throw.zip)

调用`printStackTrace()`可以打印异常的传播栈，对于调试非常有用；

捕获异常并再次抛出新的异常时，应该持有原始异常信息；

通常不要在`finally`中抛出异常。如果在`finally`中抛出异常，应该原始异常加入到原有异常中。调用方可通过`Throwable.getSuppressed()`获取所有添加的`Suppressed Exception`。
版权声明：本文为站长转载&整理，本站不享有版权，版权归原作者所有，[版权声明](https://gitee.com/hezhiyuan007/java-notes/raw/master/disclaimer.md)。




原文作者：廖雪峰的网站 原文地址：https://www.liaoxuefeng.com/