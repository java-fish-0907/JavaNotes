

  
作者：Liuwei-Sunny

出处：[https://blog.csdn.net/lovelion](https://blog.csdn.net/lovelion)

## 11.4 透明组合模式与安全组合模式

通过引入组合模式，Sunny公司设计的杀毒软件具有良好的可扩展性，在增加新的文件类型时，无须修改现有类库代码，只需增加一个新的文件类作为AbstractFile类的子类即可，但是由于在AbstractFile中声明了大量用于管理和访问成员构件的方法，例如add()、remove()等方法，我们不得不在新增的文件类中实现这些方法，提供对应的错误提示和异常处理。为了简化代码，我们有以下两个解决方案：

**解决方案一：** 将叶子构件的add()、remove()等方法的实现代码移至AbstractFile类中，由AbstractFile提供统一的默认实现，代码如下所示：

```js 
//提供默认实现的抽象构件类
    abstract class AbstractFile {
        public void add(AbstractFile file) {
            System.out.println("对不起，不支持该方法！");
        }

        public void remove(AbstractFile file) {
            System.out.println("对不起，不支持该方法！");
        }

        public AbstractFile getChild(int i) {
            System.out.println("对不起，不支持该方法！");
            return null;
        }

        public abstract void killVirus();
    }
```

如果客户端代码针对抽象类AbstractFile编程，在调用文件对象的这些方法时将出现错误提示。如果不希望出现任何错误提示，我们可以在客户端定义文件对象时不使用抽象层，而直接使用具体叶子构件本身，客户端代码片段如下所示：


```js 
class Client {
        public static void main(String args[]) {
            //不能透明处理叶子构件
            ImageFile file1,file2;
            TextFile file3,file4;
            VideoFile file5;
            AbstractFile folder1,folder2,folder3,folder4;
            //其他代码省略
          }
    }
```

这样就产生了一种不透明的使用方式，即在客户端不能全部针对抽象构件类编程，需要使用具体叶子构件类型来定义叶子对象。

**解决方案二：** 除此之外，还有一种解决方法是在抽象构件AbstractFile中不声明任何用于访问和管理成员构件的方法，代码如下所示：

```js 
abstract class AbstractFile {
        public abstract void killVirus();
    }
```

此时，由于在AbstractFile中没有声明add()、remove()等访问和管理成员的方法，其叶子构件子类无须提供实现；而且无论客户端如何定义叶子构件对象都无法调用到这些方法，不需要做任何错误和异常处理，容器构件再根据需要增加访问和管理成员的方法，但这时候也存在一个问题：客户端不得不使用容器类本身来声明容器构件对象，否则无法访问其中新增的add()、remove()等方法，如果客户端一致性地对待叶子和容器，将会导致容器构件的新增对客户端不可见，客户端代码对于容器构件无法再使用抽象构件来定义，客户端代码片段如下所示：


```js 
class Client {
        public static void main(String args[]) {

            AbstractFile file1,file2,file3,file4,file5;
            Folder folder1,folder2,folder3,folder4; //不能透明处理容器构件
            //其他代码省略
        }
    }
```

在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式：

**(1) 透明组合模式**

透明组合模式中，抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()以及getChild()等方法，这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以相同地对待所有的对象。透明组合模式也是组合模式的标准形式，虽然上面的**解决方案一**在客户端可以有不透明的实现方法，但是由于在抽象构件中包含add()、remove()等方法，因此它还是透明组合模式，透明组合模式的完整结构如图11-6所示：

![2019060910048_1.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/DesignMode2/6ec14387-fc78-49ab-9b6d-c94161fd3bf2.png)

**图11-6 透明组合模式结构图**

透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add()、remove()以及getChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。

**(2) 安全组合模式**

安全组合模式中，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法，这就是**解决方案二**所采用的实现方式。安全组合模式的结构如图11-7所示：

![2019060910048_2.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/DesignMode2/a54af61b-839c-4ea9-8c7c-fb52dec0922b.png)

**图11-7 安全组合模式结构图**

安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高，在Java AWT中使用的组合模式就是安全组合模式。
版权声明：本文为站长转载&整理，本站不享有版权，版权归原作者所有，[版权声明](https://gitee.com/hezhiyuan007/java-notes/raw/master/disclaimer.md)。




原文作者：Liuwei-Sunny 原文地址：https://blog.csdn.net/lovelion