

  
作者：Liuwei-Sunny

出处：[https://blog.csdn.net/lovelion](https://blog.csdn.net/lovelion)

## 4 使用内部类实现迭代器

在迭代器模式结构图中，我们可以看到具体迭代器类和具体聚合类之间存在双重关系，其中一个关系为关联关系，在具体迭代器中需要维持一个对具体聚合对象的引用，该关联关系的目的是访问存储在聚合对象中的数据，以便迭代器能够对这些数据进行遍历操作。

除了使用关联关系外，**为了能够让迭代器可以访问到聚合对象中的数据**，我们还**可以将迭代器类设计为聚合类的内部类**，JDK中的迭代器类就是通过这种方法来实现的，如下AbstractList类代码片段所示：

```js 
package java.util;
    ……
    public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
        ......
        private class Itr implements Iterator<E> {
            int cursor = 0;
            ......
    }
    ……
    }
```

我们可以通过类似的方法来设计第3节中的ProductList类，将ProductIterator类作为ProductList类的内部类，代码如下所示：


```js 
//商品数据类：具体聚合类
    class ProductList extends AbstractObjectList {
        public ProductList(List products) {
            super(products);
        }

        public AbstractIterator createIterator() {
            return new ProductIterator();
        }

        //商品迭代器：具体迭代器，内部类实现
        private class ProductIterator implements AbstractIterator {
            private int cursor1;
            private int cursor2;

            public ProductIterator() {
                cursor1 = 0;
                cursor2 = objects.size() -1;
            }

            public void next() {
                if(cursor1 < objects.size()) {
                    cursor1++;
                }
            }

            public boolean isLast() {
                return (cursor1 == objects.size());
            }

            public void previous() {
                if(cursor2 > -1) {
                    cursor2--;
                }
            }

            public boolean isFirst() {
                return (cursor2 == -1);
            }

            public Object getNextItem() {
                return objects.get(cursor1);
            }

            public Object getPreviousItem() {
                return objects.get(cursor2);
            }   
        }
    }
```

无论使用哪种实现机制，客户端代码都是一样的，也就是说客户端无须关心具体迭代器对象的创建细节，只需通过调用工厂方法createIterator()即可得到一个可用的迭代器对象，这也是使用工厂方法模式的好处，通过工厂来封装对象的创建过程，简化了客户端的调用。

版权声明：本文为站长转载&整理，本站不享有版权，版权归原作者所有，[版权声明](https://gitee.com/hezhiyuan007/java-notes/raw/master/disclaimer.md)。




原文作者：Liuwei-Sunny 原文地址：https://blog.csdn.net/lovelion