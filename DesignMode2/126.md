

  
作者：Liuwei-Sunny

出处：[https://blog.csdn.net/lovelion](https://blog.csdn.net/lovelion)

**(6) 观察者模式**

联机射击游戏可以实时显示队友和敌人的存活信息，如果有队友或敌人阵亡，所有在线游戏玩家将收到相应的消息，可以提供一个统一的中央角色控制类(CenterController)来实现消息传递机制，在中央角色控制器中定义一个集合用于存储所有的玩家信息，如果某玩家角色(Player)阵亡，则调用CenterController的通知方法notifyPlayers()，该方法将遍历用户信息集合，调用每一个Player的display()方法显示阵亡信息，队友阵亡和敌人阵亡的提示信息有所不同，在使用notifyPlayers()方法通知其他用户的同时，阵亡的角色对象将从用户信息集合中被删除。可使用观察者模式来实现信息的一对多发送，类图如图6所示：

![201906152001215_1.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/DesignMode2/b7eb297e-70b0-4400-be97-f955a92f7e62.png)

**图6 观察者模式实例类图**

在图6中，CenterController充当观察目标，Observer充当抽象观察者，Player充当具体观察者。在Player类中，name属性表示角色名，type属性表示角色类型，如“战队A”或“战队B”等。Player的die()方法执行时将调用CenterController的notifyPlayers()方法，在notifyPlayers()方法中调用其他Player对象的提示方法，如果是队友阵亡则调用displayTeam()，如果是敌人阵亡则调用displayEnemy()；还将调用detach()方法删除阵亡的Player对象，其中CenterController类的notifyPlayers()方法代码片段如下所示：

```js 
for(Object player : players) {
       if(player.getName().equals(name)) {
         this.detach(player);  //删除阵亡的角色
        }
       else {
           if(player.getType().equals(type)) {
               player.displayTeam(name);  //队友显示提示信息
            }
           else {
               player.displayEnemy(name);  //敌人显示提示信息
             }
       }
   }
```

**(7) 单例模式**

为了节约系统资源，在联机射击游戏中可以使用单例模式来实现一些管理器(Manager)，如场景管理器(SceneManager)、声音管理器(SoundManager)等，如图7所示的场景管理器SceneManager类：

![20190615200126_2.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/DesignMode2/dca63da7-2e6a-4fba-9340-a30b343cd085.png)

**图7 单例模式实例类图**

SceneManager类的实现代码片段如下所示【注：以下代码未考虑多线程访问的问题】：

```js 
class SceneManager {
     private static SceneManager sManager = null;

     private SceneManager() {
       //初始化代码
     }

     public synchronized static SceneManager getInstance() {
       if(sManager==null) {
         sManager = new SceneManager();
       }
       return sManager;
     }

     public void manage() {
       //业务方法
     }
   }
```

**(8) 状态模式**

在射击游戏中，游戏角色存在几种不同的状态，如正常状态、暂停状态、阵亡状态等，在不同状态下角色对象的行为不同，可使用状态模式来设计和实现角色状态的转换，类图如图8所示：

![20190615200126_3.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/DesignMode2/8211080b-b636-4869-94ea-c1e3bd84f7a4.png)

**图8 状态模式实例类图**

在图8中，游戏角色类Player充当环境类，State充当抽象状态类，其子类NormalState、PauseState和DeathState充当具体状态类，在具体状态类的pause()、start()、beAttacked()等方法中可实现状态转换，其中NormalState类的代码片段如下所示：

```js 
class NormalState extends State
   {
     public void pause()  //游戏暂停
     {
       //暂停代码省略
       player.setState(new PauseState(this));  //转为暂停状态
     }
     public void start()  //游戏启动
     {
       //游戏程序正在运行中，该方法不可用
     }
     public void beAttacked()  //被攻击
     {
       //其他代码省略
       if(lifeValue<=0)
       {
         player.setState(new DeathState(this));  //转为阵亡状态
       }
     }
     public void shot()  //射击
     {
       //代码省略
     }
     public void move()  //移动
     {
       //代码省略
     }
   }
```

**(9) 适配器模式**

为了增加游戏的灵活性，某些射击游戏还可以通过游戏手柄来进行操作，游戏手柄的操作程序和驱动程序由游戏手柄制造商提供，为了让当前的射击游戏可以与游戏手柄兼容，可使用适配器模式来进行设计，类图如图9所示：

![20190615200126_4.png](https://gitee.com/hezhiyuan007/java-study/raw/master/images/DesignMode2/d5729c6b-4180-4853-a618-db07436bf879.png)

**图9 适配器模式实例类图**

在图9中，GamepadsAdapter充当适配器，它将游戏手柄中按键(GamepadsKey)的方法适配到现有系统中，在其move()方法中可以调用MoveKey类的handle()方法，在其shot()方法中可以调用ShotKey的handle()方法，从而实现通过手柄来控制游戏运行。
版权声明：本文为站长转载&整理，本站不享有版权，版权归原作者所有，[版权声明](https://gitee.com/hezhiyuan007/java-notes/raw/master/disclaimer.md)。




原文作者：Liuwei-Sunny 原文地址：https://blog.csdn.net/lovelion