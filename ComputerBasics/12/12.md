## ã€ŒåŠ›æ‰£ã€ç¬¬ 105 é¢˜ï¼šä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ï¼ˆä¸­ç­‰ï¼‰

> æŠ“ä½ã€Œå‰åºéå†åºåˆ—ã€ä¸ã€Œä¸­åºéå†åºåˆ—ã€çš„å®šä¹‰ï¼Œé€’å½’æ„å»ºäºŒå‰æ ‘ã€‚å¹¶ä¸”é€šè¿‡ç”»å›¾è®¡ç®—å‡ºéœ€è¦ä½¿ç”¨çš„å­åŒºé—´çš„ä¸‹æ ‡ã€‚æœ€åçœ‹ä¸€çœ¼å¤æ‚åº¦ï¼Œä½¿ç”¨ã€Œç©ºé—´æ¢æ—¶é—´ã€çš„æ€è·¯ä¼˜åŒ–ã€‚

- [é“¾æ¥](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)
- [é¢˜è§£é“¾æ¥ï¼ˆå«è§†é¢‘è®²è§£ï¼‰](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/)

> æ ¹æ®ä¸€æ£µæ ‘çš„å‰åºéå†ä¸ä¸­åºéå†æ„é€ äºŒå‰æ ‘ã€‚
>
> æ³¨æ„:
> ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚
>
> ä¾‹å¦‚ï¼Œç»™å‡º
>
> ```
> å‰åºéå† preorder = [3,9,20,15,7]
> ä¸­åºéå† inorder = [9,3,15,20,7]
> ```
>
> è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š
>
> ```
>    3
>   / \
>  9  20
>    /  \
>   15   7
> ```

### æ–¹æ³•ï¼šåˆ†æ²»ç®—æ³•

- ç»“åˆã€Œå‰åºéå†åºåˆ—ã€å’Œã€Œä¸­åºéå†åºåˆ—ã€çš„å®šä¹‰ï¼›
- å‰åºéå†çš„ç¬¬ 1 ä¸ªç»“ç‚¹ä¸€å®šæ˜¯äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ï¼›
- åœ¨ä¸­åºéå†ä¸­ï¼Œæ ¹ç»“ç‚¹æŠŠä¸­åºéå†åºåˆ—åˆ†æˆäº†ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå·¦è¾¹éƒ¨åˆ†æ„æˆäº†äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹çš„å·¦å­æ ‘ï¼Œå³è¾¹éƒ¨åˆ†æ„æˆäº†äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚



æœ€åˆç‰ˆæœ¬ï¼šä¸ºäº†æ‰¾åˆ°æ ¹ç»“ç‚¹åœ¨ã€Œä¸­åºéå†åºåˆ—ã€ä¸­çš„ä¸‹æ ‡ï¼Œä½¿ç”¨äº†éå†ï¼Œå¤æ‚åº¦è¾ƒé«˜ã€‚

Java ä»£ç ï¼š

java

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;
        int inLen = inorder.length;
        if (preLen != inLen) {
            throw new RuntimeException("Incorrect input data.");
        }
        return buildTree(preorder, 0, preLen - 1, inorder, 0, inLen - 1);
    }


    /**
     * ä½¿ç”¨æ•°ç»„ preorder åœ¨ç´¢å¼•åŒºé—´ [preLeft, preRight] ä¸­çš„æ‰€æœ‰å…ƒç´ 
     * å’Œæ•°ç»„ inorder åœ¨ç´¢å¼•åŒºé—´ [inLeft, inRight] ä¸­çš„æ‰€æœ‰å…ƒç´ æ„é€ äºŒå‰æ ‘
     *
     * @param preorder äºŒå‰æ ‘å‰åºéå†ç»“æœ
     * @param preLeft  äºŒå‰æ ‘å‰åºéå†ç»“æœçš„å·¦è¾¹ç•Œ
     * @param preRight äºŒå‰æ ‘å‰åºéå†ç»“æœçš„å³è¾¹ç•Œ
     * @param inorder  äºŒå‰æ ‘ååºéå†ç»“æœ
     * @param inLeft   äºŒå‰æ ‘ååºéå†ç»“æœçš„å·¦è¾¹ç•Œ
     * @param inRight  äºŒå‰æ ‘ååºéå†ç»“æœçš„å³è¾¹ç•Œ
     * @return äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹
     */
    private TreeNode buildTree(int[] preorder, int preLeft, int preRight,
                               int[] inorder, int inLeft, int inRight) {
        // å› ä¸ºæ˜¯é€’å½’è°ƒç”¨çš„æ–¹æ³•ï¼ŒæŒ‰ç…§å›½é™…æƒ¯ä¾‹ï¼Œå…ˆå†™é€’å½’ç»ˆæ­¢æ¡ä»¶
        if (preLeft > preRight || inLeft > inRight) {
            return null;
        }
        // å…ˆåºéå†çš„èµ·ç‚¹å…ƒç´ å¾ˆé‡è¦
        int pivot = preorder[preLeft];
        TreeNode root = new TreeNode(pivot);
        int pivotIndex = inLeft;
        // ä¸¥æ ¼ä¸Šè¯´è¿˜è¦åšæ•°ç»„ä¸‹æ ‡æ˜¯å¦è¶Šç•Œçš„åˆ¤æ–­ pivotIndex < inRight
        while (inorder[pivotIndex] != pivot) {
            pivotIndex++;
        }
        root.left = buildTree(preorder, preLeft + 1, pivotIndex - inLeft + preLeft,
                inorder, inLeft, pivotIndex - 1);
        root.right = buildTree(preorder, pivotIndex - inLeft + preLeft + 1, preRight,
                inorder, pivotIndex + 1, inRight);
        return root;
    }
}
```

**å¤æ‚åº¦åˆ†æ**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘2)O(N2)ï¼Œè¿™é‡Œ ğ‘N æ˜¯äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼Œæ¯è°ƒç”¨ä¸€æ¬¡é€’å½’æ–¹æ³•åˆ›å»ºä¸€ä¸ªç»“ç‚¹ï¼Œä¸€å…±åˆ›å»º ğ‘N ä¸ªç»“ç‚¹ï¼Œåœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹ç»“ç‚¹åœ¨ä¸­åºéå†ä¸­çš„ä½ç½®ï¼Œæ˜¯ä¸ ğ‘N ç›¸å…³çš„ï¼Œè¿™é‡Œä¸è®¡ç®—é€’å½’æ–¹æ³•å ç”¨çš„æ—¶é—´ï¼›
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(1)O(1)ï¼Œè¿™é‡Œä¸è®¡ç®—é€’å½’æ–¹æ³•å ç”¨çš„ç©ºé—´ã€‚



æœ€ç»ˆç‰ˆæœ¬ï¼šæŠŠä¸­åºéå†åºåˆ—ä¸­çš„æ•°å€¼å’Œä¸‹æ ‡å­˜åœ¨å“ˆå¸Œè¡¨é‡Œï¼Œæ–¹ä¾¿åé¢ä½¿ç”¨ã€‚

Java ä»£ç ï¼š

java

```java
import java.util.HashMap;
import java.util.Map;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;
        int inLen = inorder.length;

        if (preLen != inLen) {
            throw new RuntimeException("Incorrect input data.");
        }

        Map<Integer, Integer> map = new HashMap<>(preLen);
        for (int i = 0; i < inLen; i++) {
            map.put(inorder[i], i);
        }
        return buildTree(preorder, 0, preLen - 1, map, 0, inLen - 1);
    }


    /**
     * @param preorder å‰åºéå†åºåˆ—
     * @param preLeft  å‰åºéå†åºåˆ—å­åŒºé—´çš„å·¦è¾¹ç•Œï¼Œå¯ä»¥å–åˆ°
     * @param preRight å‰åºéå†åºåˆ—å­åŒºé—´çš„å³è¾¹ç•Œï¼Œå¯ä»¥å–åˆ°
     * @param map      åœ¨ä¸­åºéå†åºåˆ—é‡Œï¼Œæ•°å€¼ä¸ä¸‹æ ‡çš„å¯¹åº”å…³ç³»
     * @param inLeft   ä¸­åºéå†åºåˆ—å­åŒºé—´çš„å·¦è¾¹ç•Œï¼Œå¯ä»¥å–åˆ°
     * @param inRight  å‰åºéå†åºåˆ—å­åŒºé—´çš„å³è¾¹ç•Œï¼Œå¯ä»¥å–åˆ°
     * @return
     */
    private TreeNode buildTree(int[] preorder, int preLeft, int preRight,
                               Map<Integer, Integer> map, int inLeft, int inRight) {
        if (preLeft > preRight || inLeft > inRight) {
            return null;
        }

        int rootVal = preorder[preLeft];
        TreeNode root = new TreeNode(rootVal);
        int pIndex = map.get(rootVal);
        root.left = buildTree(preorder, preLeft + 1, pIndex - inLeft + preLeft,
                map, inLeft, pIndex - 1);

        root.right = buildTree(preorder, pIndex - inLeft + preLeft + 1, preRight,
                map, pIndex + 1, inRight);
        return root;
    }
}
```

**å¤æ‚åº¦åˆ†æ**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ï¼Œè¿™é‡Œ ğ‘N æ˜¯äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼Œæ¯è°ƒç”¨ä¸€æ¬¡é€’å½’æ–¹æ³•åˆ›å»ºä¸€ä¸ªç»“ç‚¹ï¼Œä¸€å…±åˆ›å»º ğ‘N ä¸ªç»“ç‚¹ï¼Œè¿™é‡Œä¸è®¡ç®—é€’å½’æ–¹æ³•å ç”¨çš„æ—¶é—´ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ï¼Œè¿™é‡Œå¿½ç•¥é€’å½’æ–¹æ³•å ç”¨çš„ç©ºé—´ï¼Œå› ä¸ºæ˜¯å¯¹æ•°çº§åˆ«çš„ï¼Œæ¯” ğ‘N å°ã€‚