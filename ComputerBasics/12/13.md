## ã€ŒåŠ›æ‰£ã€ç¬¬ 106 é¢˜ï¼šä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

- é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal
- æˆ‘å†™çš„é¢˜è§£åœ°å€ï¼šhttps://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-bian-li-python-dai-ma-java-dai-ma-by-liwe-2/

> æ ¹æ®ä¸€æ£µæ ‘çš„ä¸­åºéå†ä¸ååºéå†æ„é€ äºŒå‰æ ‘ã€‚
>
> æ³¨æ„:
> ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚
>
> ä¾‹å¦‚ï¼Œç»™å‡º
>
> ```
> ä¸­åºéå† inorder = [9,3,15,20,7]
> ååºéå† postorder = [9,15,7,20,3]
> ```
>
> è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š
>
> ```
>    3
>   / \
>  9  20
>    /  \
>   15   7
> ```

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰

è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

```
# https://www.bilibili.com/video/av7420546?from=search&seid=6242384381313003008
# å‰åºéå†çš„ç¬¬ 1 ä¸ªç‚¹è‚¯å®šæ˜¯æ ¹ç»“ç‚¹
# å‚è€ƒèµ„æ–™ï¼šhttps://articles.leetcode.com/construct-binary-tree-from-inorder-and-preorder-postorder-traversal/
```

# LeetCode ç¬¬ 106 é¢˜ï¼š

äºŒå‰æ ‘ç›¸å…³çš„å¾ˆå¤šé—®é¢˜çš„è§£å†³æ€è·¯éƒ½æœ‰åˆ†æ²»æ³•çš„æ€æƒ³åœ¨é‡Œé¢ã€‚

æˆ‘ä»¬å†å¤ä¹ ä¸€ä¸‹åˆ†æ²»æ³•çš„æ€æƒ³ï¼š**æŠŠåŸé—®é¢˜æ‹†è§£æˆè‹¥å¹²ä¸ªä¸åŸé—®é¢˜ç»“æ„ç›¸åŒä½†è§„æ¨¡æ›´å°çš„å­é—®é¢˜ï¼Œå¾…å­é—®é¢˜è§£å†³ä»¥åï¼ŒåŸé—®é¢˜å°±å¾—ä»¥è§£å†³**ï¼Œâ€œå½’å¹¶æ’åºâ€ å’Œ â€œå¿«é€Ÿæ’åºâ€ éƒ½æ˜¯åˆ†æ²»æ³•æ€æƒ³çš„åº”ç”¨ï¼Œå…¶ä¸­ â€œå½’å¹¶æ’åºâ€ å…ˆæ— è„‘åœ°â€œåˆ†â€ï¼Œåœ¨ â€œåˆâ€ çš„æ—¶å€™å°±éº»çƒ¦ä¸€äº›ï¼›â€œå¿«é€Ÿæ’åºâ€ å¼€å§‹åœ¨ partition ä¸ŠèŠ±äº†å¾ˆå¤šæ—¶é—´ï¼Œå³åœ¨ â€œåˆ†â€ ä¸Šä½¿äº†å¾ˆå¤šåŠ²ï¼Œç„¶åå°±é€’å½’å¤„ç†ä¸‹å»å°±å¥½äº†ï¼Œæ²¡æœ‰åœ¨ â€œåˆâ€ ä¸Šå†èŠ±æ—¶é—´ã€‚

ä»¥é¢˜ç›®ä¸­ç»™å‡ºçš„ä¾‹å­ä¸ºä¾‹ï¼Œè®²è§£å¦‚ä½•æ„å»ºäºŒå‰æ ‘ã€‚

> ä¸­åºéå† `inorder = [9,3,15,20,7]`
> ååºéå† `postorder = [9,15,7,20,3]`



![image.png](https://pic.leetcode-cn.com/5dcc2ad3599fffb757d2746278fc2cba0a9bdf79e1e452bb4885ccb8c72e557d-image.png)

**image.png**



å›¾ç”»å®Œä»¥åæ‰å‘ç°è¿™ä¸ªä¾‹å­ä¸å¤ªå¥½ï¼Œæ•°ç»„é•¿åº¦å¤šä¸€äº›å°±èƒ½æŠŠæ€è·¯å±•ç°å¾—æ›´æ¸…æ¥šäº†ï¼Œå„ä½å®¢å®˜è€çˆ·å°†å°±çœ‹ä¸€ä¸‹å•¦ã€‚æˆ–è€…å¯ä»¥çœ‹ä¸€ä¸‹æˆ‘å†™çš„ [ã€ŒåŠ›æ‰£ã€ç¬¬ 105 é¢˜](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) çš„ [é¢˜è§£](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/) ï¼Œä¸¤é“é—®é¢˜çš„è§£æ³•æ˜¯ä¸€æ ·çš„ã€‚

**æ³¨æ„**ï¼šè¿™é“é—®é¢˜å…¶å®å¹¶ä¸éš¾ï¼Œæˆ‘ä»¬åœ¨è‰ç¨¿çº¸ä¸Šå†™å†™ç”»ç”»ï¼Œå°±èƒ½æŠŠæ€è·¯æƒ³æ¸…æ¥šï¼Œä½†æ˜¯åœ¨ç¼–ç ä¸Šä¼šæœ‰ä¸€äº›å°é™·é˜±ï¼Œåœ¨è®¡ç®—ç´¢å¼•è¾¹ç•Œå€¼è¦è®¤çœŸä¸€äº›ã€‚

ä¸‹é¢ç»™å‡ºä¸¤ç§å†™æ³•ï¼ŒåŒºåˆ«åœ¨äºç©ºé—´å¤æ‚åº¦ï¼š

### æ–¹æ³•ä¸€ï¼šåœ¨é€’å½’æ–¹æ³•ä¸­ï¼Œä¼ å…¥æ•°ç»„çš„æ‹·è´

è¯¥æ–¹æ³•åœ¨è®¡ç®—ç´¢å¼•çš„æ—¶å€™ä¼šç¨å¾®å®¹æ˜“ä¸€äº›ã€‚

Python ä»£ç ï¼š

Python

```Python
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def buildTree(self, inorder, postorder):
        assert len(inorder) == len(postorder)

        if len(inorder) == 0:
            return None
        if len(inorder) == 1:
            # è¿™é‡Œè¦è¿”å›ç»“ç‚¹ï¼Œè€Œä¸æ˜¯è¿”å›å…·ä½“çš„æ•°
            return TreeNode(inorder[0])
        # ååºéå†çš„æœ€åä¸€ä¸ªç»“ç‚¹å°±æ˜¯æ ¹ç»“ç‚¹
        root = TreeNode(postorder[-1])
        # åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹ç»“ç‚¹çš„ç´¢å¼•ï¼Œå¾—åˆ°å·¦å³å­æ ‘çš„ä¸€ä¸ªåˆ’åˆ†
        pos = inorder.index(postorder[-1])
        # è¿™é‡Œçš„åˆ—è¡¨åˆ‡ç‰‡ä½¿ç”¨çš„æ˜¯å¤åˆ¶å€¼ï¼Œä½¿ç”¨äº†ä¸€äº›ç©ºé—´ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦æ˜¯ O(N)
        root.left = self.buildTree(inorder[:pos], postorder[:pos])
        root.right = self.buildTree(inorder[pos + 1:], postorder[pos:-1])
```

Java ä»£ç ï¼š

Java

```Java
import java.util.Arrays;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {
    /**
     * @param inorder   ä¸­åºéå†åºåˆ—
     * @param postorder ååºéå†åºåˆ—
     * @return
     */
    public TreeNode buildTree(int[] inorder, int[] postorder) {

        int inlen = inorder.length;
        int postlen = postorder.length;

        assert inlen == postlen;

        if (inlen == 0) {
            return null;
        }
        if (inlen == 1) {
            return new TreeNode(inorder[0]);
        }

        // ååºéå†çš„æœ€åä¸€ä¸ªç»“ç‚¹å°±æ˜¯æ ¹ç»“ç‚¹
        int rootVal = postorder[postlen - 1];
        // åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹ç»“ç‚¹çš„ç´¢å¼•ï¼Œå¾—åˆ°å·¦å³å­æ ‘çš„ä¸€ä¸ªåˆ’åˆ†
        int dividePoint = 0;
        for (int i = 0; i < inlen; i++) {
            if (inorder[i] == rootVal) {
                dividePoint = i;
                break;
            }
        }
        TreeNode rootNode = new TreeNode(rootVal);
        // Arrays.copyOfRange() æ–¹æ³•çš„ç¬¬ 1 ä¸ªå‚æ•°æ˜¯æºæ•°ç»„
        // ç¬¬ 2 ä¸ªå‚æ•°æ˜¯æºæ•°ç»„çš„èµ·å§‹ä½ç½®ï¼ˆå¯ä»¥å–åˆ°ï¼‰
        // ç¬¬ 3 ä¸ªå‚æ•°æ˜¯æºæ•°ç»„çš„èµ·å§‹ä½ç½®ï¼ˆä¸å¯ä»¥å–åˆ°ï¼‰
        // è¿™é‡Œå¤åˆ¶äº†æ•°ç»„ï¼Œä½¿ç”¨äº†ä¸€äº›ç©ºé—´ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦æ˜¯ O(N)
        rootNode.left = buildTree(Arrays.copyOfRange(inorder, 0, dividePoint), Arrays.copyOfRange(postorder, 0, dividePoint));
        rootNode.right = buildTree(Arrays.copyOfRange(inorder, dividePoint + 1, inlen), Arrays.copyOfRange(postorder, dividePoint, postlen - 1));
        return rootNode;
    }
}
```

**å¤æ‚åº¦åˆ†æï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ï¼Œè¿™é‡Œ ğ‘N æ˜¯äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ã€‚

### æ–¹æ³•äºŒï¼šåœ¨é€’å½’æ–¹æ³•ä¸­ï¼Œä¼ å…¥å­æ•°ç»„çš„è¾¹ç•Œç´¢å¼•

**æ³¨æ„**ï¼šåœ¨é€’å½’æ–¹æ³•ä¸­ï¼Œæœ‰ä¸€ä¸ªæ•°ç»„çš„è¾¹ç•Œç´¢å¼•ï¼Œå¾—é€šè¿‡è®¡ç®—å¾—åˆ°ï¼Œè®¡ç®—çš„ä¾æ®æ˜¯é€’å½’æ–¹æ³•ä¼ å…¥çš„â€œä¸­åºéå†æ•°ç»„â€ï¼ˆçš„å­æ•°ç»„ï¼‰å’Œâ€œååºéå†æ•°ç»„â€ï¼ˆçš„å­æ•°ç»„ï¼‰çš„é•¿åº¦æ˜¯ä¸€æ ·çš„ã€‚æˆ‘çš„åŠæ³•æ˜¯è§£æ–¹ç¨‹è®¡ç®—æœªçŸ¥æ•°ï¼Œå“ˆå“ˆï¼Œå‚»å‘¼å‘¼çš„ã€‚å…·ä½“éœ€è¦è®¡ç®—å“ªä¸ªå‚æ•°æˆ‘åœ¨ä¸‹é¢çš„ä»£ç ä¸­å·²ç»æ³¨æ˜äº†ã€‚

Python ä»£ç ï¼š

python

```python
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def __init__(self):
        self.inorder = None
        self.postorder = None

    def buildTree(self, inorder, postorder):
        assert len(inorder) == len(postorder)
        size = len(inorder)

        self.inorder = inorder
        self.postorder = postorder
        return self.__dfs(0, size - 1, 0, size - 1)

    def __dfs(self, in_l, in_r, post_l, post_r):
        if in_l > in_r or post_l > post_r:
            return None

        val = self.postorder[post_r]
        # ååºéå†çš„æœ€åä¸€ä¸ªç»“ç‚¹å°±æ˜¯æ ¹ç»“ç‚¹
        root = TreeNode(val)
        # åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹ç»“ç‚¹çš„ç´¢å¼•ï¼Œå¾—åˆ°å·¦å³å­æ ‘çš„ä¸€ä¸ªåˆ’åˆ†
        pos = self.inorder.index(val)

        # æ³¨æ„ï¼šç¬¬ 4 ä¸ªå‚æ•°æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¾æ®ï¼šä¸¤è¾¹åŒºé—´é•¿åº¦ç›¸ç­‰
        root.left = self.__dfs(in_l, pos - 1, post_l, pos - 1 - in_l + post_l)
        # æ³¨æ„ï¼šç¬¬ 3 ä¸ªå‚æ•°æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¾æ®ï¼šä¸¤è¾¹åŒºé—´é•¿åº¦ç›¸ç­‰
        root.right = self.__dfs(pos + 1, in_r, post_r - in_r + pos, post_r - 1)
        return root
```

Java ä»£ç ï¼š

java

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {

    private int[] inorder;
    private int[] postorder;


    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder = inorder;
        this.postorder = postorder;
        int len = inorder.length;
        return dfs(0, len - 1, 0, len - 1);
    }


    private TreeNode dfs(int inl, int inr, int postl, int postr) {
        if (inl > inr || postl > postr) {
            return null;
        }

        int val = postorder[postr];
        int k = 0;
        for (int i = inl; i < inr + 1; i++) {
            if (inorder[i] == val) {
                k = i;
                break;
            }
        }

        TreeNode root = new TreeNode(val);
        // æ³¨æ„ï¼šç¬¬ 4 ä¸ªå‚æ•°æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¾æ®ï¼šä¸¤è¾¹åŒºé—´é•¿åº¦ç›¸ç­‰
        root.left = dfs(inl, k - 1, postl, k - 1 - inl + postl);
        // æ³¨æ„ï¼šç¬¬ 3 ä¸ªå‚æ•°æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¾æ®ï¼šä¸¤è¾¹åŒºé—´é•¿åº¦ç›¸ç­‰
        root.right = dfs(k + 1, inr, postr + k - inr, postr - 1);
        return root;
    }

    public static void main(String[] args) {
        int[] inorder = {1, 3, 2};
        int[] postorder = {3, 2, 1};

        Solution solution = new Solution();

        TreeNode res = solution.buildTree(inorder, postorder);
        System.out.println(res);
    }
}
```

**å¤æ‚åº¦åˆ†æï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ï¼Œè¿™é‡Œ ğ‘N æ˜¯äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(1)O(1)ã€‚

# é¢˜ç›®æè¿°ï¼ˆä¸­ç­‰éš¾åº¦ï¼‰

æˆ‘å†™çš„é¢˜è§£åœ°å€ï¼š



![img](https://windliang.oss-cn-beijing.aliyuncs.com/106.jpg)



æ ¹æ®äºŒå‰æ ‘çš„ä¸­åºéå†å’Œååºéå†è¿˜åŸäºŒå‰æ ‘ã€‚

# æ€è·¯åˆ†æ

å¯ä»¥å…ˆçœ‹ä¸€ä¸‹ [105 é¢˜](https://leetcode.wang/leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.html)ï¼Œç›´æ¥åœ¨ 105 é¢˜çš„åŸºç¡€ä¸Šæ”¹äº†ï¼Œå¤§å®¶ä¹Ÿå¯ä»¥å…ˆæ ¹æ® 105 é¢˜æ”¹ä¸€æ”¹ã€‚

105 é¢˜ç»™çš„æ˜¯å…ˆåºéå†å’Œä¸­åºéå†ï¼Œè¿™é‡ŒæŠŠå…ˆåºéå†æ¢æˆäº†ååºéå†ã€‚

åŒºåˆ«åœ¨äºå…ˆåºéå†çš„é¡ºåºæ˜¯ æ ¹èŠ‚ç‚¹ -> å·¦å­æ ‘ -> å³å­æ ‘ã€‚

ååºéå†çš„é¡ºåºæ˜¯ å·¦å­æ ‘ -> å³å­æ ‘ -> æ ¹èŠ‚ç‚¹ã€‚

æˆ‘ä»¬å½“ç„¶è¿˜æ˜¯å…ˆç¡®å®šæ ¹èŠ‚ç‚¹ï¼Œç„¶ååœ¨ä¸­åºéå†ä¸­æ‰¾æ ¹èŠ‚ç‚¹çš„ä½ç½®ï¼Œç„¶ååˆ†å‡ºå·¦å­æ ‘å’Œå³å­æ ‘ã€‚

å¯¹äºä¹‹å‰çš„è§£æ³•ä¸€ï¼Œä¼ æ•°ç»„çš„ä¸¤ä¸ªè¾¹ç•Œï¼Œå½±å“ä¸å¤§ï¼Œåªè¦é‡æ–°è®¡ç®—è¾¹ç•Œå°±å¯ä»¥äº†ã€‚

ä½†æ˜¯å¯¹äºå¦å¤–ä¸¤ç§è§£æ³•ï¼Œåˆ©ç”¨ stop å’Œæ ˆçš„ç®—æ³•ï¼Œä¹‹å‰éƒ½æ˜¯é€šè¿‡éå†å‰åºéå†çš„æ•°ç»„å®ç°çš„ã€‚æ‰€ä»¥æ„é€ è¿‡ç¨‹æ˜¯æ ¹èŠ‚ç‚¹ï¼Œå·¦å­æ ‘ï¼Œå³å­æ ‘ã€‚

ä½†è¿™é‡Œå¦‚æœæ˜¯ååºéå†ï¼Œæˆ‘ä»¬å…ˆæ‰¾æ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥ç›¸å½“äºä»å³å¾€å·¦éå†ï¼Œè¿™æ ·çš„é¡ºåºçš„è¯å°±æˆäº†ï¼Œæ ¹èŠ‚ç‚¹ -> å³å­æ ‘ -> å·¦å­æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šå…ˆç”Ÿæˆå³å­æ ‘ï¼Œå†ç”Ÿæˆå·¦å­æ ‘ã€‚

# è§£æ³•ä¸€

å¸¸è§„è§£æ³•ï¼Œåˆ©ç”¨é€’å½’ï¼Œä¼ é€’å·¦å­æ ‘å’Œå³å­æ ‘çš„æ•°ç»„èŒƒå›´å³å¯ã€‚

java

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    return buildTreeHelper(inorder, 0, inorder.length, postorder, 0, postorder.length, map);
}

private TreeNode buildTreeHelper(int[] inorder, int i_start, int i_end, int[] postorder, int p_start, int p_end,
                                 HashMap<Integer, Integer> map) {
    if (p_start == p_end) {
        return null;
    }
    int root_val = postorder[p_end - 1];
    TreeNode root = new TreeNode(root_val);
    int i_root_index = map.get(root_val);
    int leftNum = i_root_index - i_start;
    root.left = buildTreeHelper(inorder, i_start, i_root_index, postorder, p_start, p_start + leftNum, map);
    root.right = buildTreeHelper(inorder, i_root_index + 1, i_end, postorder, p_start + leftNum, p_end - 1,
                                 map);
    return root;
}
```

# è§£æ³•äºŒ stop å€¼

è¿™é‡Œçš„è¯ï¼Œä¹‹å‰è¯´äº†ï¼Œé€’å½’çš„è¯å¾—å…ˆæ„é€ å³å­æ ‘å†æ„é€ å·¦å­æ ‘ï¼Œæ­¤å¤–å„ç§æŒ‡é’ˆï¼Œä¹Ÿåº”è¯¥ä»æœ«å°¾å‘é›¶èµ°ã€‚

è§†çº¿ä»å³å¾€å·¦çœ‹ã€‚

java

```java
    3
   / \
  9  20
    /  \
   15   7

s åˆå§‹åŒ–ä¸€ä¸ªæ ‘ä¸­æ‰€æœ‰çš„æ•°å­—éƒ½ä¸ä¼šç›¸ç­‰çš„æ•°ï¼Œæ‰€ä»¥ä»£ç ä¸­ç”¨äº†ä¸€ä¸ª long æ¥è¡¨ç¤º
<------------------
ä¸­åº
  9, 3, 15, 20, 7
^               ^
s               i

ååº
9, 15, 7, 20, 3
              ^  
              p
<-------------------
```

`p` å’Œ `i` éƒ½ä»å³å¾€å·¦è¿›è¡Œéå†ï¼Œæ‰€ä»¥ `p` å¼€å§‹äº§ç”Ÿçš„æ¯æ¬¡éƒ½æ˜¯å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ä¹‹å‰ä»£ç é‡Œçš„`++`è¦ç›¸åº”çš„æ”¹æˆ`--`ã€‚

java

```java
int post;
int in; 
public TreeNode buildTree(int[] inorder, int[] postorder) {
    post = postorder.length - 1;
    in = inorder.length - 1;
    return buildTreeHelper(inorder, postorder, (long) Integer.MIN_VALUE - 1);
}

private TreeNode buildTreeHelper(int[] inorder, int[] postorder, long stop) {
    if (post == -1) {
        return null;
    }
    if (inorder[in] == stop) {
        in--;
        return null;
    }
    int root_val = postorder[post--];
    TreeNode root = new TreeNode(root_val);
    root.right = buildTreeHelper(inorder, postorder, root_val);
    root.left = buildTreeHelper(inorder, postorder, stop);
    return root;
}
```

# è§£æ³•ä¸‰ æ ˆ

ä¹‹å‰è§£æ³•æ˜¯æ„é€ å·¦å­æ ‘ã€å·¦å­æ ‘ã€å·¦å­æ ‘ï¼Œå‡ºç°ç›¸ç­‰ï¼Œæ„é€ ä¸€é¢—å³å­æ ‘ã€‚è¿™é‡Œç›¸åº”çš„è¦æ”¹æˆæ„é€ å³å­æ ‘ã€å³å­æ ‘ã€å³å­æ ‘ï¼Œå‡ºç°ç›¸ç­‰ï¼Œæ„é€ ä¸€é¢—å·¦å­æ ‘ã€‚å’Œè§£æ³•äºŒä¸€æ ·ï¼Œä¸¤ä¸ªæŒ‡é’ˆçš„è¯ä¹Ÿæ˜¯ä»æœ«å°¾åˆ°å¤´éƒ¨è¿›è¡Œã€‚

java

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    if (postorder.length == 0) {
        return null;
    }
    Stack<TreeNode> roots = new Stack<TreeNode>();
    int post = postorder.length - 1;
    int in = inorder.length - 1;
    TreeNode curRoot = new TreeNode(postorder[post]);
    TreeNode root = curRoot;
    roots.push(curRoot);
    post--;
    while (post >=  0) {
        if (curRoot.val == inorder[in]) {
            while (!roots.isEmpty() && roots.peek().val == inorder[in]) {
                curRoot = roots.peek();
                roots.pop();
                in--;
            }
            curRoot.left = new TreeNode(postorder[post]);
            curRoot = curRoot.left;
            roots.push(curRoot);
            post--;
        } else {
            curRoot.right = new TreeNode(postorder[post]);
            curRoot = curRoot.right;
            roots.push(curRoot);
            post--;
        }
    }
    return root;
}
```

# æ€»

ç†è§£äº† [105 é¢˜](https://leetcode.wang/leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.html) çš„è¯ï¼Œè¿™é“é¢˜å¾ˆå¿«å°±å‡ºæ¥äº†ï¼Œå®Œå…¨æ˜¯ 105 é¢˜çš„é€†å‘æ€è€ƒã€‚