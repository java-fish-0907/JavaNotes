## ã€ŒåŠ›æ‰£ã€ç¬¬ 105 é¢˜ï¼šä»Žå‰åºä¸Žä¸­åºéåŽ†åºåˆ—æž„é€ äºŒå‰æ ‘

é¢˜è§£åœ°å€ï¼š[åˆ†æ²»æ³•ï¼ˆPython ä»£ç ã€Java ä»£ç ï¼‰](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/)ã€‚

è¯´æ˜Žï¼šæ–‡æœ¬é¦–å‘åœ¨åŠ›æ‰£çš„é¢˜è§£ç‰ˆå—ï¼Œæ›´æ–°ä¹Ÿä¼šåœ¨ç¬¬ 1 æ—¶é—´åœ¨ä¸Šé¢çš„ç½‘ç«™ä¸­æ›´æ–°ï¼Œè¿™ç¯‡æ–‡ç« åªæ˜¯ä¸Šé¢çš„æ–‡ç« çš„ä¸€ä¸ªå¿«ç…§ï¼Œæ‚¨å¯ä»¥ç‚¹å‡»ä¸Šé¢çš„é“¾æŽ¥çœ‹åˆ°å…¶ä»–ç½‘å‹å¯¹æœ¬æ–‡çš„è¯„è®ºã€‚

ä¼ é€é—¨ï¼š[105. ä»Žå‰åºä¸Žä¸­åºéåŽ†åºåˆ—æž„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)ã€‚

> æ ¹æ®ä¸€æ£µæ ‘çš„å‰åºéåŽ†ä¸Žä¸­åºéåŽ†æž„é€ äºŒå‰æ ‘ã€‚
>
> æ³¨æ„:
> ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚
>
> ä¾‹å¦‚ï¼Œç»™å‡º
>
> å‰åºéåŽ† preorder = [3,9,20,15,7]
> ä¸­åºéåŽ† inorder = [9,3,15,20,7]
> è¿”å›žå¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š
>
> 3
> /
> 9 20
> /
> 15 7

## åˆ†æ²»æ³•ï¼ˆPython ä»£ç ã€Java ä»£ç ï¼‰

**æ€è·¯åˆ†æž**ï¼š

äºŒå‰æ ‘ç›¸å…³çš„å¾ˆå¤šé—®é¢˜çš„è§£å†³æ€è·¯éƒ½æœ‰åˆ†æ²»æ³•çš„æ€æƒ³åœ¨é‡Œé¢ã€‚æˆ‘ä»¬å¤ä¹ ä¸€ä¸‹åˆ†æ²»æ³•çš„æ€æƒ³ï¼š**æŠŠåŽŸé—®é¢˜æ‹†è§£æˆè‹¥å¹²ä¸ªä¸ŽåŽŸé—®é¢˜ç»“æž„ç›¸åŒä½†è§„æ¨¡æ›´å°çš„å­é—®é¢˜ï¼Œå¾…å­é—®é¢˜è§£å†³ä»¥åŽï¼ŒåŽŸé—®é¢˜å°±å¾—ä»¥è§£å†³**ï¼Œâ€œå½’å¹¶æŽ’åºâ€å’Œâ€œå¿«é€ŸæŽ’åºâ€éƒ½æ˜¯åˆ†æ²»æ³•æ€æƒ³çš„åº”ç”¨ï¼Œå…¶ä¸­â€œå½’å¹¶æŽ’åºâ€å…ˆæ— è„‘åœ°â€œåˆ†â€ï¼Œåœ¨â€œåˆâ€çš„æ—¶å€™å°±éº»çƒ¦ä¸€äº›ï¼›â€œå¿«é€ŸæŽ’åºâ€å¼€å§‹åœ¨ partition ä¸ŠèŠ±äº†å¾ˆå¤šæ—¶é—´ï¼Œå³åœ¨â€œåˆ†â€ä¸Šä½¿äº†å¾ˆå¤šåŠ²ï¼Œç„¶åŽå°±é€’å½’å¤„ç†ä¸‹åŽ»å°±å¥½äº†ï¼Œæ²¡æœ‰åœ¨â€œåˆâ€ä¸Šå†èŠ±æ—¶é—´ã€‚

æŠ“ä½â€œå‰åºéåŽ†çš„ç¬¬ 1 ä¸ªå…ƒç´ ä¸€å®šæ˜¯äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹â€ï¼Œä¸éš¾å†™å‡ºä»£ç ã€‚å…³é”®è¿˜æ˜¯æ‹¿ LeetCode ä¸Šé¢çš„ä¾‹å­ç”»ä¸€ä¸ªå›¾ï¼Œæ€è·¯å°±å¾ˆæ¸…æ™°äº†ã€‚

å‰åºéåŽ†æ•°ç»„çš„ç¬¬ 11 ä¸ªæ•°ï¼ˆç´¢å¼•ä¸º 00ï¼‰çš„æ•°ä¸€å®šæ˜¯äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ï¼ŒäºŽæ˜¯å¯ä»¥åœ¨ä¸­åºéåŽ†ä¸­æ‰¾è¿™ä¸ªæ ¹ç»“ç‚¹çš„ç´¢å¼•ï¼Œç„¶åŽæŠŠâ€œå‰åºéåŽ†æ•°ç»„â€å’Œâ€œä¸­åºéåŽ†æ•°ç»„â€åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œå°±åˆ†åˆ«å¯¹åº”äºŒå‰æ ‘çš„å·¦å­æ ‘å’Œå³å­æ ‘ï¼Œåˆ†åˆ«é€’å½’å®Œæˆå°±å¯ä»¥äº†ã€‚



![105-1.png](https://pic.leetcode-cn.com/fe215cdc993b06a2eeca7939ac04d370f3fe725e7e568e6ced17d1757020be9f-105-1.png)

**105-1.png**



è¿™é“é¢˜å®Œæˆäº†ä»¥åŽå¯ä»¥é¡ºä¾¿æŠŠ [ã€ŒåŠ›æ‰£ã€ ç¬¬ 106 é¢˜ï¼šä»Žä¸­åºä¸ŽåŽåºéåŽ†åºåˆ—æž„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)ä¹Ÿä¸€èµ·åšäº†ï¼ŒåŠ æ²¹åŠ æ²¹ï¼

**å‚è€ƒä»£ç **ï¼š

Python ä»£ç ï¼š

Python

```Python
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):

    def buildTree(self, preorder, inorder):
        plen = len(preorder)
        ilen = len(inorder)
        return self.__helper(preorder, 0, plen - 1, inorder, 0, ilen - 1)

    def __helper(self, preorder, prel, prer,
                 inorder, inl, inr):
        if prel > prer:
            return None
        root_val = preorder[prel]
        l = inl
        while l < inr and inorder[l] != root_val:
            l += 1
        # èµ°åˆ°è¿™é‡Œ inorder[l] == root ä¸º True
        root_node = TreeNode(root_val)
        root_node.left = self.__helper(preorder, prel + 1, prel + l - inl,
                                       inorder, inl, l - 1)
        root_node.right = self.__helper(preorder, prel + l - inl + 1, prer,
                                        inorder, l + 1, inr)
        return root_node
```

Java ä»£ç ï¼š

Java

```Java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {

    // ä½¿ç”¨å‰åºéåŽ†å’Œä¸­åºéåŽ†æž„å»ºäºŒå‰æ ‘
    // ä¸¾å‡ºå…·ä½“ä¾‹å­æ¥åˆ†æžå°±ä¼šå¾ˆæ¸…æ™°ï¼Œè¿™é‡Œä¸€å®šè¦åˆ†æžæ¸…æ¥šç´¢å¼•çš„èµ·å§‹
    // ä¾‹å¦‚ï¼š
    // pre: A B D E H I C F K G
    // in : D B H E I A F K C G

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;
        int inLen = inorder.length;
        return helper(preorder, 0, preLen - 1, inorder, 0, inLen - 1);
    }


    private TreeNode helper(int[] preorder,
                            int preL, int preR,
                            int[] inorder,
                            int inL, int inR) {
        if (preL > preR || inL > inR) {
            return null;
        }
        int rootVal = preorder[preL];
        int l = inL;
        while (l <= inR && inorder[l] != rootVal) {
            l++;
        }
        TreeNode root = new TreeNode(rootVal);
        root.left = helper(preorder, preL + 1, preL + l - inL, inorder, inL, l - 1);
        root.right = helper(preorder, preL + l - inL + 1, preR, inorder, l + 1, inR);
        return root;
    }
}
```

**å¤æ‚åº¦åˆ†æžï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šð‘‚(ð‘)O(N)ï¼Œè¿™é‡Œ ð‘N æ˜¯äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šð‘‚(ð‘)O(N)ã€‚