## ã€ŒåŠ›æ‰£ã€ç¬¬ 106 é¢˜ï¼šä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

é¢˜è§£åœ°å€ï¼š[åˆ†æ²»æ³•ï¼ˆPythonã€Javaï¼‰](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-bian-li-python-dai-ma-java-dai-ma-by-liwe-2/)ã€‚

è¯´æ˜ï¼šæ–‡æœ¬é¦–å‘åœ¨åŠ›æ‰£çš„é¢˜è§£ç‰ˆå—ï¼Œæ›´æ–°ä¹Ÿä¼šåœ¨ç¬¬ 1 æ—¶é—´åœ¨ä¸Šé¢çš„ç½‘ç«™ä¸­æ›´æ–°ï¼Œè¿™ç¯‡æ–‡ç« åªæ˜¯ä¸Šé¢çš„æ–‡ç« çš„ä¸€ä¸ªå¿«ç…§ï¼Œæ‚¨å¯ä»¥ç‚¹å‡»ä¸Šé¢çš„é“¾æ¥çœ‹åˆ°å…¶ä»–ç½‘å‹å¯¹æœ¬æ–‡çš„è¯„è®ºã€‚

ä¼ é€é—¨ï¼š[106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)ã€‚

> æ ¹æ®ä¸€æ£µæ ‘çš„ä¸­åºéå†ä¸ååºéå†æ„é€ äºŒå‰æ ‘ã€‚
>
> æ³¨æ„:
> ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚
>
> ä¾‹å¦‚ï¼Œç»™å‡º
>
> ä¸­åºéå† inorder = [9,3,15,20,7]
> ååºéå† postorder = [9,15,7,20,3]
> è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š
>
> 
>
> ```
> 3
> /
> 9 20
> /
> 15 7
> ```
>
> 

## åˆ†æ²»æ³•ï¼ˆPythonã€Javaï¼‰

**æ€è·¯åˆ†æ**ï¼š

äºŒå‰æ ‘ç›¸å…³çš„å¾ˆå¤šé—®é¢˜çš„è§£å†³æ€è·¯éƒ½æœ‰åˆ†æ²»æ³•çš„æ€æƒ³åœ¨é‡Œé¢ã€‚

å¤ä¹ ä¸€ä¸‹åˆ†æ²»æ³•çš„æ€æƒ³ï¼š**æŠŠåŸé—®é¢˜æ‹†è§£æˆè‹¥å¹²ä¸ªä¸åŸé—®é¢˜ç»“æ„ç›¸åŒä½†è§„æ¨¡æ›´å°çš„å­é—®é¢˜ï¼Œå¾…å­é—®é¢˜è§£å†³ä»¥åï¼ŒåŸé—®é¢˜å°±å¾—ä»¥è§£å†³**ï¼Œâ€œå½’å¹¶æ’åºâ€ å’Œ â€œå¿«é€Ÿæ’åºâ€ éƒ½æ˜¯åˆ†æ²»æ³•æ€æƒ³çš„åº”ç”¨ï¼Œå…¶ä¸­ â€œå½’å¹¶æ’åºâ€ å…ˆæ— è„‘åœ°â€œåˆ†â€ï¼Œåœ¨ â€œåˆâ€ çš„æ—¶å€™å°±éº»çƒ¦ä¸€äº›ï¼›â€œå¿«é€Ÿæ’åºâ€ å¼€å§‹åœ¨ partition ä¸ŠèŠ±äº†å¾ˆå¤šæ—¶é—´ï¼Œå³åœ¨ â€œåˆ†â€ ä¸Šä½¿äº†å¾ˆå¤šåŠ²ï¼Œç„¶åå°±é€’å½’å¤„ç†ä¸‹å»å°±å¥½äº†ï¼Œæ²¡æœ‰åœ¨ â€œåˆâ€ ä¸Šå†èŠ±æ—¶é—´ã€‚

ä»¥é¢˜ç›®ä¸­ç»™å‡ºçš„ä¾‹å­ä¸ºä¾‹ï¼Œè®²è§£å¦‚ä½•æ„å»ºäºŒå‰æ ‘ã€‚

> ä¸­åºéå† `inorder = [9,3,15,20,7]`
> ååºéå† `postorder = [9,15,7,20,3]`



![106-1.png](https://pic.leetcode-cn.com/40c56ab66dc7288be11bc93fe9e31fd05daf6d6377fae8d1aa11054a67b4d62f-106-1.png)

**106-1.png**



å›¾ç”»å®Œä»¥åæ‰å‘ç°è¿™ä¸ªä¾‹å­ä¸å¤ªå¥½ï¼Œæ•°ç»„é•¿åº¦å¤šä¸€äº›å°±èƒ½æŠŠæ€è·¯å±•ç°å¾—æ›´æ¸…æ¥šäº†ï¼Œå„ä½å®¢å®˜è€çˆ·å°†å°±çœ‹ä¸€ä¸‹å•¦ã€‚æˆ–è€…å¯ä»¥çœ‹ä¸€ä¸‹æˆ‘å†™çš„ã€ŒåŠ›æ‰£ã€ç¬¬ 105 é¢˜çš„é¢˜è§£[ã€Šåˆ†æ²»æ³•ï¼ˆPython ä»£ç ã€Java ä»£ç ï¼‰ã€‹](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/)ï¼Œä¸¤é“é—®é¢˜çš„è§£æ³•æ˜¯ä¸€æ ·çš„ã€‚

**æ³¨æ„**ï¼šè¿™é“é—®é¢˜å…¶å®å¹¶ä¸éš¾ï¼Œæˆ‘ä»¬åœ¨è‰ç¨¿çº¸ä¸Šå†™å†™ç”»ç”»ï¼Œå°±èƒ½æŠŠæ€è·¯æƒ³æ¸…æ¥šï¼Œä½†æ˜¯åœ¨ç¼–ç ä¸Šä¼šæœ‰ä¸€äº›å°é™·é˜±ï¼Œåœ¨è®¡ç®—ç´¢å¼•è¾¹ç•Œå€¼è¦è®¤çœŸä¸€äº›ã€‚

ä¸‹é¢ç»™å‡ºä¸¤ç§å†™æ³•ï¼ŒåŒºåˆ«åœ¨äºç©ºé—´å¤æ‚åº¦ï¼š

### æ–¹æ³•ä¸€ï¼šåœ¨é€’å½’æ–¹æ³•ä¸­ï¼Œä¼ å…¥æ•°ç»„çš„æ‹·è´ï¼ˆäº†è§£ï¼Œä¸æ¨èï¼‰

è¯¥æ–¹æ³•åœ¨è®¡ç®—ç´¢å¼•çš„æ—¶å€™ä¼šç¨å¾®å®¹æ˜“ä¸€äº›ã€‚

**å‚è€ƒä»£ç  1**ï¼š

Python ä»£ç ï¼š





Python

```Python
from typing import List


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        assert len(inorder) == len(postorder)

        if len(inorder) == 0:
            return None
        if len(inorder) == 1:
            # è¿™é‡Œè¦è¿”å›ç»“ç‚¹ï¼Œè€Œä¸æ˜¯è¿”å›å…·ä½“çš„æ•°
            return TreeNode(inorder[0])
        # ååºéå†çš„æœ€åä¸€ä¸ªç»“ç‚¹å°±æ˜¯æ ¹ç»“ç‚¹
        root = TreeNode(postorder[-1])
        # åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹ç»“ç‚¹çš„ç´¢å¼•ï¼Œå¾—åˆ°å·¦å³å­æ ‘çš„ä¸€ä¸ªåˆ’åˆ†
        pos = inorder.index(postorder[-1])
        # è¿™é‡Œçš„åˆ—è¡¨åˆ‡ç‰‡ä½¿ç”¨çš„æ˜¯å¤åˆ¶å€¼ï¼Œä½¿ç”¨äº†ä¸€äº›ç©ºé—´ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦æ˜¯ O(N)
        root.left = self.buildTree(inorder[:pos], postorder[:pos])
        root.right = self.buildTree(inorder[pos + 1:], postorder[pos:-1])
        return root
```

Java ä»£ç ï¼š

Java

```Java
import java.util.Arrays;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {
    /**
     * @param inorder   ä¸­åºéå†åºåˆ—
     * @param postorder ååºéå†åºåˆ—
     * @return
     */
    public TreeNode buildTree(int[] inorder, int[] postorder) {

        int inlen = inorder.length;
        int postlen = postorder.length;

        assert inlen == postlen;

        if (inlen == 0) {
            return null;
        }
        if (inlen == 1) {
            return new TreeNode(inorder[0]);
        }

        // ååºéå†çš„æœ€åä¸€ä¸ªç»“ç‚¹å°±æ˜¯æ ¹ç»“ç‚¹
        int rootVal = postorder[postlen - 1];
        // åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹ç»“ç‚¹çš„ç´¢å¼•ï¼Œå¾—åˆ°å·¦å³å­æ ‘çš„ä¸€ä¸ªåˆ’åˆ†
        int dividePoint = 0;
        for (int i = 0; i < inlen; i++) {
            if (inorder[i] == rootVal) {
                dividePoint = i;
                break;
            }
        }
        TreeNode rootNode = new TreeNode(rootVal);
        // Arrays.copyOfRange() æ–¹æ³•çš„ç¬¬ 1 ä¸ªå‚æ•°æ˜¯æºæ•°ç»„
        // ç¬¬ 2 ä¸ªå‚æ•°æ˜¯æºæ•°ç»„çš„èµ·å§‹ä½ç½®ï¼ˆå¯ä»¥å–åˆ°ï¼‰
        // ç¬¬ 3 ä¸ªå‚æ•°æ˜¯æºæ•°ç»„çš„èµ·å§‹ä½ç½®ï¼ˆä¸å¯ä»¥å–åˆ°ï¼‰
        // è¿™é‡Œå¤åˆ¶äº†æ•°ç»„ï¼Œä½¿ç”¨äº†ä¸€äº›ç©ºé—´ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦æ˜¯ O(N)
        rootNode.left = buildTree(Arrays.copyOfRange(inorder, 0, dividePoint), Arrays.copyOfRange(postorder, 0, dividePoint));
        rootNode.right = buildTree(Arrays.copyOfRange(inorder, dividePoint + 1, inlen), Arrays.copyOfRange(postorder, dividePoint, postlen - 1));
        return rootNode;
    }
}
```

**å¤æ‚åº¦åˆ†æï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘logğ‘)O(Nlogâ¡N)ï¼Œè¿™é‡Œ ğ‘N æ˜¯äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼Œç®—æ³•ä¸­æ¯ä¸ªç»“ç‚¹éƒ½ä¼šè¢«çœ‹åˆ°ä¸€æ¬¡ï¼Œæ˜¯çº¿æ€§çº§åˆ«çš„ï¼Œé€’å½’çš„æ·±åº¦æ˜¯å¯¹æ•°çº§åˆ«çš„ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦æ˜¯ ğ‘‚(ğ‘logğ‘)O(Nlogâ¡N)ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ï¼Œæ„é€ ä¸€æ£µæ ‘éœ€è¦ ğ‘N ä¸ªç»“ç‚¹ï¼ˆå¾…è®¨è®ºï¼‰ã€‚

### æ–¹æ³•äºŒï¼šåœ¨é€’å½’æ–¹æ³•ä¸­ï¼Œä¼ å…¥å­æ•°ç»„çš„è¾¹ç•Œç´¢å¼•

**æ³¨æ„**ï¼šåœ¨é€’å½’æ–¹æ³•ä¸­ï¼Œæœ‰ä¸€ä¸ªæ•°ç»„çš„è¾¹ç•Œç´¢å¼•ï¼Œå¾—é€šè¿‡è®¡ç®—å¾—åˆ°ï¼Œè®¡ç®—çš„ä¾æ®æ˜¯é€’å½’æ–¹æ³•ä¼ å…¥çš„â€œä¸­åºéå†æ•°ç»„â€ï¼ˆçš„å­æ•°ç»„ï¼‰å’Œâ€œååºéå†æ•°ç»„â€ï¼ˆçš„å­æ•°ç»„ï¼‰çš„é•¿åº¦æ˜¯ä¸€æ ·çš„ã€‚æˆ‘çš„åŠæ³•æ˜¯è§£æ–¹ç¨‹è®¡ç®—æœªçŸ¥æ•°ï¼Œå“ˆå“ˆï¼Œå‚»å‘¼å‘¼çš„ã€‚å…·ä½“éœ€è¦è®¡ç®—å“ªä¸ªå‚æ•°æˆ‘åœ¨ä¸‹é¢çš„ä»£ç ä¸­å·²ç»æ³¨æ˜äº†ã€‚

**å‚è€ƒä»£ç  2**ï¼š

Python ä»£ç ï¼š

Python

```Python
from typing import List


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:

    def __init__(self):
        self.inorder = None
        self.postorder = None

    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        assert len(inorder) == len(postorder)
        size = len(inorder)

        self.inorder = inorder
        self.postorder = postorder
        return self.__dfs(0, size - 1, 0, size - 1)

    def __dfs(self, in_l, in_r, post_l, post_r):
        if in_l > in_r or post_l > post_r:
            return None

        val = self.postorder[post_r]
        # ååºéå†çš„æœ€åä¸€ä¸ªç»“ç‚¹å°±æ˜¯æ ¹ç»“ç‚¹
        root = TreeNode(val)
        # åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹ç»“ç‚¹çš„ç´¢å¼•ï¼Œå¾—åˆ°å·¦å³å­æ ‘çš„ä¸€ä¸ªåˆ’åˆ†
        pos = self.inorder.index(val)

        # æ³¨æ„ï¼šç¬¬ 4 ä¸ªå‚æ•°æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¾æ®ï¼šä¸¤è¾¹åŒºé—´é•¿åº¦ç›¸ç­‰
        root.left = self.__dfs(in_l, pos - 1, post_l, pos - 1 - in_l + post_l)
        # æ³¨æ„ï¼šç¬¬ 3 ä¸ªå‚æ•°æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¾æ®ï¼šä¸¤è¾¹åŒºé—´é•¿åº¦ç›¸ç­‰
        root.right = self.__dfs(pos + 1, in_r, post_r - in_r + pos, post_r - 1)
        return root
```

Java ä»£ç ï¼š





Java

```Java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public class Solution {

    private int[] inorder;
    private int[] postorder;


    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder = inorder;
        this.postorder = postorder;
        int len = inorder.length;
        return dfs(0, len - 1, 0, len - 1);
    }


    private TreeNode dfs(int inl, int inr, int postl, int postr) {
        if (inl > inr || postl > postr) {
            return null;
        }

        int val = postorder[postr];
        int k = 0;
        for (int i = inl; i < inr + 1; i++) {
            if (inorder[i] == val) {
                k = i;
                break;
            }
        }

        TreeNode root = new TreeNode(val);
        // æ³¨æ„ï¼šç¬¬ 4 ä¸ªå‚æ•°æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¾æ®ï¼šä¸¤è¾¹åŒºé—´é•¿åº¦ç›¸ç­‰
        root.left = dfs(inl, k - 1, postl, k - 1 - inl + postl);
        // æ³¨æ„ï¼šç¬¬ 3 ä¸ªå‚æ•°æ˜¯è®¡ç®—å‡ºæ¥çš„ï¼Œä¾æ®ï¼šä¸¤è¾¹åŒºé—´é•¿åº¦ç›¸ç­‰
        root.right = dfs(k + 1, inr, postr + k - inr, postr - 1);
        return root;
    }

    public static void main(String[] args) {
        int[] inorder = {1, 3, 2};
        int[] postorder = {3, 2, 1};

        Solution solution = new Solution();

        TreeNode res = solution.buildTree(inorder, postorder);
        System.out.println(res);
    }
}
```

**å¤æ‚åº¦åˆ†æï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘logğ‘)O(Nlogâ¡N)ï¼Œè¿™é‡Œ ğ‘N æ˜¯äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼Œç®—æ³•ä¸­æ¯ä¸ªç»“ç‚¹éƒ½ä¼šè¢«çœ‹åˆ°ä¸€æ¬¡ï¼Œæ˜¯çº¿æ€§çº§åˆ«çš„ï¼Œé€’å½’çš„æ·±åº¦æ˜¯å¯¹æ•°çº§åˆ«çš„ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦æ˜¯ ğ‘‚(ğ‘logğ‘)O(Nlogâ¡N)ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ï¼Œæ„é€ ä¸€æ£µæ ‘éœ€è¦ ğ‘N ä¸ªç»“ç‚¹ï¼ˆå¾…è®¨è®ºï¼‰ã€‚