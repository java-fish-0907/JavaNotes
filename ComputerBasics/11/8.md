## ã€ŒåŠ›æ‰£ã€ç¬¬ 128 é¢˜ï¼šæœ€é•¿è¿ç»­åºåˆ—ï¼ˆå›°éš¾ï¼‰

> è¿™é“é¢˜å› ä¸ºæœ‰åˆ¤æ–­ã€Œæ˜¯å¦åœ¨å¹¶æŸ¥é›†ã€ä¸­çš„éœ€è¦ï¼Œå› æ­¤éœ€è¦æŠŠå¹¶æŸ¥é›†çš„åº•å±‚æ•°ç»„è®¾ç½®ä¸ºã€Œå“ˆå¸Œè¡¨ã€ã€‚

- [é“¾æ¥](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

> ç»™å®šä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºæœ€é•¿è¿ç»­åºåˆ—çš„é•¿åº¦ã€‚
>
> è¦æ±‚ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(ğ‘›)O(n)ã€‚
>
> **ç¤ºä¾‹**ï¼š
>
> ```
> è¾“å…¥: [100, 4, 200, 1, 3, 2]
> è¾“å‡º: 4
> è§£é‡Š: æœ€é•¿è¿ç»­åºåˆ—æ˜¯ [1, 2, 3, 4]ã€‚å®ƒçš„é•¿åº¦ä¸º 4ã€‚
> ```

æ³¨æ„ï¼šè¿™é‡Œå°è£…çš„ã€Œå¹¶æŸ¥é›†ã€æœ‰ä¸€äº›ç‰¹æ®Šï¼Œ`union` æ–¹æ³•è¿”å›çš„æ˜¯ `size` ï¼Œå¯ä»¥ç†è§£æˆåŸºäº `size` åˆå¹¶çš„æ„æ€ï¼Œè¿™é‡Œçš„ `size` åœ¨è¿™é“é—®é¢˜é‡Œæ˜¯æœ‰å®é™…æ„ä¹‰ã€‚

ç†è§£ï¼š

- åºåˆ—ï¼šå³å­åºåˆ—ï¼Œä¸éœ€è¦è¿ç»­ï¼›
- ä¸¥æ ¼ä¸Šå‡ï¼Œå¹¶ä¸”é—´éš”æ˜¯ 11ï¼Œæ‰èƒ½å½¢æˆæœ€é•¿ã€‚

å…³é”®çš„åœ°æ–¹åœ¨äºè¿ç»­ã€‚

### æ–¹æ³•ä¸€ï¼šæš´åŠ›è§£æ³•ï¼ˆæ—¶é—´å¤æ‚åº¦ä¸ç¬¦åˆè¦æ±‚ï¼‰

- å…ˆæ’åºï¼Œç„¶åé€ä¸ªåˆ¤æ–­æ˜¯å¦è¿ç»­ã€‚

Java ä»£ç ï¼š

java

```java
import java.util.Arrays;

public class Solution {

    public int longestConsecutive(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        Arrays.sort(nums);

        int longestLen = 1;
        int res = 1;
        int pre = nums[0];
        for (int i = 1; i < len; i++) {
            if (nums[i] == nums[i - 1]) {
                // é‡å¤å…ƒç´ è¦å»æ‰
                continue;
            } else if (nums[i] == (pre + 1)) {
                longestLen++;
                res = Math.max(res, longestLen);
            } else {
                longestLen = 1;
            }
            pre = nums[i];
        }
        return res;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        // int[] nums = new int[]{100, 4, 200, 1, 3, 2};
        int[] nums = new int[]{1, 2, 0, 1};
        int res = solution.longestConsecutive(nums);
        System.out.println(res);
    }
}
```

**å¤æ‚åº¦åˆ†æ**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘logğ‘+ğ‘)O(Nlogâ¡N+N)
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(1)O(1)

### æ–¹æ³•äºŒï¼šå“ˆå¸Œè¡¨

- ç©ºé—´æ¢æ—¶é—´ï¼šæ¯ä¸ªæ•°ä¼šè¢«çœ‹ `3` æ¬¡ã€‚

Java ä»£ç ï¼š

java

```java
import java.util.HashSet;
import java.util.Set;

public class Solution {

    public int longestConsecutive(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        // é™¤äº†å¿«é€ŸæŸ¥æ‰¾ï¼Œè¿˜æœ‰å»é‡çš„æ•ˆæœï¼Œå¦‚æœæœ‰å¾ˆå¤šèµ·ç‚¹ï¼Œä¼šé‡å¤è®¡ç®—
        Set<Integer> hashSet = new HashSet<>(len);
        for (int num : nums) {
            hashSet.add(num);
        }

        // æœ€é•¿è¿ç»­å­åºåˆ—çš„é•¿åº¦
        int res = 0;
        for (int num : hashSet) {
            // å…³é”®ï¼šä¿è¯è¿ç»­åºåˆ—çš„èµ·ç‚¹æœ€å°
            if (hashSet.contains(num - 1)) {
                continue;
            }

            int longestLen = 1;
            // éå†æ‰¾å‡ºä»¥ num ä¸ºèµ·ç‚¹çš„é—´éš”ä¸º 1 çš„æœ€é•¿è¿ç»­å­åºåˆ—
            while (hashSet.contains(num + 1)) {
                longestLen++;
                num++;
            }

            res = Math.max(res, longestLen);
        }
        return res;
    }
}
```

**å¤æ‚åº¦åˆ†æ**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ï¼Œæ¯ä¸€ä¸ªæ•°ä¼šè¢«çœ‹ 33 éã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ã€‚

### æ–¹æ³•ä¸‰ï¼šé’ˆå¯¹æ–¹æ³•äºŒçš„ä¼˜åŒ–

Java ä»£ç ï¼š

java

```java
import java.util.HashMap;
import java.util.Map;

public class Solution {

    public int longestConsecutive(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        // keyï¼šnums[i] ä¸­çš„æ•°å€¼
        // valueï¼šä»¥ nums[i] ä¸ºè¾¹ç•Œçš„ã€Œè¿ç»­ã€æ•°ç»„çš„é•¿åº¦ï¼Œåªæœ‰è¾¹ç•Œæ‰æœ‰æ„ä¹‰
        Map<Integer, Integer> hashMap = new HashMap<>(len);

        int res = 1;
        for (int num : nums) {
            if (hashMap.containsKey(num)) {
                continue;
            }

            Integer leftBound = hashMap.get(num - 1);
            Integer rightBound = hashMap.get(num + 1);

            if (leftBound == null && rightBound == null) {
                hashMap.put(num, 1);
            } else if (leftBound != null && rightBound != null) {
                int longestLen = leftBound + rightBound + 1;
                res = Math.max(res, longestLen);

                // num åªéœ€è¦å ä¸€ä¸ªä½ç½®å³å¯ï¼Œnum - leftBound å’Œ num + rightBound çš„å®šä¹‰éœ€è¦å‡†ç¡®
                hashMap.put(num, 0);
                hashMap.put(num - leftBound, longestLen);
                hashMap.put(num + rightBound, longestLen);
            } else if (leftBound == null) {
                int longestLen = rightBound + 1;
                res = Math.max(res, longestLen);

                hashMap.put(num, longestLen);
                hashMap.put(num + rightBound, longestLen);
            } else {
                // rightBound == null
                int longestLen = leftBound + 1;
                res = Math.max(res, longestLen);

                hashMap.put(num, longestLen);
                hashMap.put(num - leftBound, longestLen);
            }
        }
        return res;
    }

    // 100(1), 4(4),200(1),1(4),3(2),2(0)

    public static void main(String[] args) {
        Solution3 solution3 = new Solution3();
        int[] nums = new int[]{100, 4, 200, 1, 3, 2};

        // int[] nums = new int[]{4, 0, -4, -2, 2, 5, 2, 0, -8, -8, -8, -8, -1, 7, 4, 5, 5, -4, 6, 6, -3};
        // int[] nums = new int[]{1, 2, 0, 1};
        int res = solution3.longestConsecutive(nums);
        System.out.println(res);
    }
}
```

**å¤æ‚åº¦åˆ†æ**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ï¼Œæ¯ä¸€ä¸ªæ•°ä¼šè¢«çœ‹ 11 éã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ã€‚

### æ–¹æ³•å››ï¼šå¹¶æŸ¥é›†

- å¹¶æŸ¥é›†åº•å±‚ç”¨ã€Œå“ˆå¸Œè¡¨ã€å®ç°ï¼›
- å› æ­¤è®¾è®¡ `size` ï¼Œè¿™é‡Œæ˜¯ã€ŒæŒ‰ç§©åˆå¹¶ã€çš„æ€æƒ³ï¼Œã€Œç§©ã€è¡¨ç¤ºä»¥å¹¶æŸ¥é›†æ ¹ç»“ç‚¹ä¸ºå­æ ‘çš„ç»“ç‚¹çš„ä¸ªæ•°ï¼›
- æ”¹é€  `union` æ–¹æ³•ï¼Œè¿”å›åˆå¹¶ä»¥åçš„æ–°çš„è¿é€šåˆ†é‡çš„ç»“ç‚¹ä¸ªæ•°ã€‚

Java ä»£ç ï¼š

java

```java
import java.util.HashMap;
import java.util.Map;

public class Solution {

    public int longestConsecutive(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        UnionFind unionFind = new UnionFind(nums);
        int res = 1;
        for (int num : nums) {
            if (unionFind.contains(num - 1)) {
                res = Math.max(res, unionFind.union(num, num - 1));
            }

            if (unionFind.contains(num + 1)) {
                res = Math.max(res, unionFind.union(num, num + 1));
            }
        }
        return res;
    }

    /**
     * ç”±äºæ•°å€¼æ˜¯ç¦»æ•£çš„ï¼Œparent æ•°ç»„ä½¿ç”¨å“ˆå¸Œè¡¨ä»£æ›¿
     */
    private class UnionFind {

        private Map<Integer, Integer> parent;
        // ç»´æŠ¤ä»¥å½“å‰ç»“ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„ç»“ç‚¹æ€»æ•°
        private Map<Integer, Integer> size;

        public UnionFind(int[] nums) {
            int len = nums.length;
            parent = new HashMap<>(len);
            size = new HashMap<>(len);

            for (int num : nums) {
                parent.put(num, num);
                size.put(num, 1);
            }
        }

        /**
         * union æ–¹æ³•è¿”å›äº†ä»¥åˆå¹¶ä»¥åçš„è¿é€šåˆ†é‡çš„ç»“ç‚¹ä¸ªæ•°
         *
         * @param x
         * @param y
         * @return
         */
        public int union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);

            if (rootX == rootY) {
                return 0;
            }

            int sizeX = size.get(rootX);
            int sizeY = size.get(rootY);

            int sum = sizeX + sizeY;
            if (sizeX < sizeY) {
                parent.put(rootX, rootY);
                size.put(rootY, sum);
            } else {
                parent.put(rootY, rootX);
                size.put(rootX, sum);
            }
            return sum;
        }

        public int find(int x) {
            while (x != parent.get(x)) {
                // å®ç°äº†è·¯å¾„å‹ç¼©ï¼Œåº•ä¸‹é‚£äº›ç»“ç‚¹é”™äº†æ²¡æœ‰å…³ç³»ï¼Œæ ¹ç»“ç‚¹å¯¹å°±å¯ä»¥äº†
                parent.put(x, parent.get(parent.get(x)));
                x = parent.get(x);
            }
            return x;
        }

        /**
         * æ–°å¢ contains æ–¹æ³•
         *
         * @param x
         * @return
         */
        public boolean contains(int x) {
            return parent.containsKey(x);
        }
    }
}
```

**å¤æ‚åº¦åˆ†æ**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼šå¹³å‡æ„ä¹‰ä¸‹ ï¼Œğ‘‚(ğ‘)O(N)ï¼Œæ¯ä¸€ä¸ªæ•°ä¼šè¢«çœ‹ 11 éã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘)O(N)ã€‚