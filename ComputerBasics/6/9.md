## ã€ŒåŠ›æ‰£ã€ç¬¬ 23 é¢˜ï¼šåˆå¹¶ K ä¸ªæ’åºé“¾è¡¨ï¼ˆå›°éš¾ï¼‰

- é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/merge-k-sorted-lists
- æˆ‘å†™çš„é¢˜è§£åœ°å€ï¼šhttps://leetcode-cn.com/problems/merge-k-sorted-lists/solution/tan-xin-suan-fa-you-xian-dui-lie-fen-zhi-fa-python/

> åˆå¹¶ `k` ä¸ªæ’åºé“¾è¡¨ï¼Œè¿”å›åˆå¹¶åçš„æ’åºé“¾è¡¨ã€‚è¯·åˆ†æå’Œæè¿°ç®—æ³•çš„å¤æ‚åº¦ã€‚
>
> ç¤ºä¾‹ï¼š
>
> ```
> è¾“å…¥:
> [
>   1 -> 4 -> 5,
>   1 -> 3 -> 4,
>   2 -> 6
> ]
> è¾“å‡º: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 ->6
> ```

| é¢˜ç›®åœ°å€                                                     | é¢˜è§£                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [LeetCode ç¬¬ 23 é¢˜ï¼šåˆå¹¶Kä¸ªæ’åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/) | [è´ªå¿ƒç®—æ³•ã€ä¼˜å…ˆé˜Ÿåˆ— + åˆ†æ²»æ³•ï¼ˆPython ä»£ç ã€Java ä»£ç ï¼‰](https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/tan-xin-suan-fa-you-xian-dui-lie-fen-zhi-fa-python/) |

### æ–¹æ³•ä¸€ï¼šè´ªå¿ƒç®—æ³•ã€ä¼˜å…ˆé˜Ÿåˆ—

æ€è·¯åˆ†æï¼š

1ã€ç”±äºæ˜¯ ğ‘˜k ä¸ªæ’åºé“¾è¡¨ï¼Œé‚£ä¹ˆè¿™ ğ‘˜k ä¸ªæ’åºçš„é“¾è¡¨**å¤´ç»“ç‚¹**ä¸­ `val` **æœ€å°**çš„ç»“ç‚¹å°±æ˜¯åˆå¹¶ä»¥åçš„é“¾è¡¨ä¸­æœ€å°çš„ç»“ç‚¹ï¼›

2ã€æœ€å°ç»“ç‚¹æ‰€åœ¨çš„é“¾è¡¨çš„å¤´ç»“ç‚¹å°±è¦æ›´æ–°äº†ï¼Œæ›´æ–°æˆæœ€å°ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œæ­¤æ—¶è¿˜æ˜¯è¿™ ğ‘˜k ä¸ªé“¾è¡¨ï¼Œè¿™ ğ‘˜k ä¸ªæ’åºçš„é“¾è¡¨**å¤´ç»“ç‚¹**ä¸­ `val` **æœ€å°**çš„ç»“ç‚¹å°±æ˜¯åˆå¹¶ä»¥åçš„é“¾è¡¨ä¸­ç¬¬ 22 å°çš„ç»“ç‚¹ã€‚

å†™åˆ°è¿™é‡Œï¼Œæˆ‘æƒ³ä½ åº”è¯¥å·®ä¸å¤šæ˜ç™½äº†ï¼Œæˆ‘ä»¬æ¯ä¸€æ¬¡éƒ½ä»è¿™ ğ‘˜k ä¸ªæ’åºçš„é“¾è¡¨**å¤´ç»“ç‚¹**ä¸­æ‹¿å‡º `val` æœ€å°çš„ç»“ç‚¹â€œç©¿é’ˆå¼•çº¿â€æˆæ–°çš„é“¾è¡¨ï¼Œè¿™ä¸ªé“¾è¡¨å°±æ˜¯é¢˜ç›®è¦æ±‚çš„â€œåˆå¹¶åçš„æ’åºé“¾è¡¨â€ã€‚â€œå±€éƒ¨æœ€ä¼˜ï¼Œå…¨å±€å°±æœ€ä¼˜â€ï¼Œè¿™ä¸å°±æ˜¯è´ªå¿ƒç®—æ³•çš„æ€æƒ³å—ã€‚

è¿™é‡Œæˆ‘ä»¬ä¸¾ç”Ÿæ´»ä¸­çš„ä¾‹å­æ¥ç†è§£è¿™ä¸ªæ€è·¯ã€‚

> å‡è®¾ä½ æ˜¯ä¸€åä½“è‚²è€å¸ˆï¼Œæœ‰ 33 ä¸ªç­çš„å­¦ç”Ÿï¼Œä»–ä»¬å·²ç»æŒ‰ç…§èº«é«˜ä»çŸ®åˆ°é«˜æ’å¥½æˆäº† 33 åˆ—çºµé˜Ÿï¼Œç°åœ¨è¦æŠŠè¿™ 33 ä¸ªç­çš„å­¦ç”Ÿä¹ŸæŒ‰ç…§èº«é«˜ä»çŸ®åˆ°é«˜æ’åˆ— 11 åˆ—çºµé˜Ÿã€‚æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆåšï¼š
> 1ã€è®© 33 ä¸ªç­çš„å­¦ç”ŸæŒ‰åˆ—ç«™åœ¨ä½ çš„é¢å‰ï¼Œè¿™æ—¶ä½ èƒ½çœ‹åˆ°ç«™åœ¨é˜Ÿé¦–çš„å­¦ç”Ÿçš„å…¨èº«ï¼›
> 2ã€æ¯ä¸€æ¬¡é˜Ÿé¦–çš„ 33 ååŒå­¦ï¼Œè¯·æœ€çŸ®çš„åŒå­¦å‡ºåˆ—åˆ°â€œé˜Ÿä¼4â€ï¼ˆå³æˆ‘ä»¬æœ€ç»ˆè®¤ä¸ºæ’å¥½åºçš„é˜Ÿåˆ—ï¼‰ï¼Œå‡ºåˆ—çš„è¿™ä¸€åˆ—çš„åé¢çš„æ‰€æœ‰åŒå­¦éƒ½å‘å‰èµ°ä¸€æ­¥ï¼ˆå…¶å®èµ°ä¸èµ°éƒ½è¡Œï¼Œåªè¦ä½ èƒ½æ¯”è¾ƒå‡ºç«™åœ¨ä½ é¢å‰çš„ 3 ä½åœ¨é˜Ÿé¦–çš„åŒå­¦åŒå­¦çš„é«˜çŸ®å³å¯ï¼‰ï¼›
> 3ã€é‡å¤ç¬¬ 2 æ­¥ï¼Œç›´åˆ° 33 ä¸ªç­çš„åŒå­¦å…¨éƒ¨å‡ºåˆ—å®Œæ¯•ã€‚

å…·ä½“å®ç°çš„æ—¶å€™ï¼Œâ€œæ¯ä¸€æ¬¡é˜Ÿé¦–çš„ 33 ååŒå­¦ï¼Œè¯·æœ€çŸ®çš„åŒå­¦å‡ºåˆ—â€è¿™ä»¶äº‹æƒ…å¯ä»¥äº¤ç»™**ä¼˜å…ˆé˜Ÿåˆ—**ï¼ˆæœ€å°å †ã€æœ€å°ç´¢å¼•å †å‡å¯ï¼‰å»å®Œæˆã€‚åœ¨è¿ç»­çš„ä¸¤æ¬¡å‡ºé˜Ÿä¹‹é—´å®Œæˆâ€œç©¿é’ˆå¼•çº¿â€çš„å·¥ä½œã€‚

ä¸‹é¢çš„å›¾è§£é‡Šäº†ä¸Šé¢çš„æ€è·¯ã€‚



![LeetCode ç¬¬ 23 é¢˜ï¼šåˆå¹¶Kä¸ªæ’åºé“¾è¡¨-1](https://liweiwei1419.github.io/images/leetcode-solution/23-1.png)

**LeetCode ç¬¬ 23 é¢˜ï¼šåˆå¹¶Kä¸ªæ’åºé“¾è¡¨-1**





![LeetCode ç¬¬ 23 é¢˜ï¼šåˆå¹¶Kä¸ªæ’åºé“¾è¡¨-2](https://liweiwei1419.github.io/images/leetcode-solution/23-2.png)

**LeetCode ç¬¬ 23 é¢˜ï¼šåˆå¹¶Kä¸ªæ’åºé“¾è¡¨-2**





![LeetCode ç¬¬ 23 é¢˜ï¼šåˆå¹¶Kä¸ªæ’åºé“¾è¡¨-3](https://liweiwei1419.github.io/images/leetcode-solution/23-3.png)

**LeetCode ç¬¬ 23 é¢˜ï¼šåˆå¹¶Kä¸ªæ’åºé“¾è¡¨-3**



Python3 ä»£ç ï¼šPython3 çš„ `heapq` æ¨¡å—ä¼ å…¥çš„ `tuple` å¯¹è±¡é‡Œé¢ä¸èƒ½æœ‰å¼•ç”¨å¯¹è±¡ï¼Œå°±åªå¥½ä¼ ä¸€ä¸ªç´¢å¼•è¿›å»äº†ã€‚

Python

```Python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        import heapq
        l = []
        size = len(lists)

        for index in range(size):
            if lists[index]:
                heapq.heappush(l, (lists[index].val, index))

        dummy_node = ListNode(-1)
        cur = dummy_node

        while l:
            _, index = heapq.heappop(l)

            head = lists[index]

            cur.next = head
            cur = cur.next
            if head.next:
                heapq.heappush(l, (head.next.val, index))
                lists[index] = head.next
                head.next = None

        return dummy_node.next
```

Python2 ä»£ç ï¼š

Python

```Python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        import heapq
        l = []
        for head in lists:
            if head:
                heapq.heappush(l, (head.val, head))
        dummy_node = ListNode(-1)
        cur = dummy_node

        while l:
            _, head = heapq.heappop(l)
            cur.next = head
            cur = cur.next
            if head.next:
                heapq.heappush(l, (head.next.val, head.next))

        return dummy_node.next
```

Java ä»£ç ï¼šä¿ç•™äº†ä¸€äº›è°ƒè¯•ä»£ç ï¼Œä¾›å„ä½å‚è€ƒã€‚

Java

```Java
import java.util.Comparator;
import java.util.PriorityQueue;

class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }

    ListNode(Integer[] nums) {
        ListNode currNode = this;
        currNode.val = nums[0];
        for (int i = 1; i < nums.length; i++) {
            currNode.next = new ListNode(nums[i]);
            currNode = currNode.next;
        }
    }

    @Override
    public String toString() {
        ListNode currNode = this;
        StringBuilder s = new StringBuilder();
        while (currNode != null) {
            s.append(currNode.val);
            s.append(" -> ");
            currNode = currNode.next;
        }
        // æœ€åæ·»åŠ ä¸€ä¸ª NULL æ ‡å¿—è¡¨ç¤ºæ·»åŠ åˆ°æœ«å°¾äº†
        s.append("NULL");
        return s.toString();
    }
}

public class Solution {

    public ListNode mergeKLists(ListNode[] lists) {
        int len = lists.length;
        if (len == 0) {
            return null;
        }
        PriorityQueue priorityQueue = new PriorityQueue<>(len, Comparator.comparingInt(a -> a.val));
        ListNode dummyNode = new ListNode(-1);
        ListNode curNode = dummyNode;
        for (ListNode list : lists) {
            if (list != null) {
                // è¿™ä¸€æ­¥å¾ˆå…³é”®ï¼Œä¸èƒ½ä¹Ÿæ²¡æœ‰å¿…è¦å°†ç©ºå¯¹è±¡æ·»åŠ åˆ°ä¼˜å…ˆé˜Ÿåˆ—ä¸­
                priorityQueue.add(list);
            }
        }
        while (!priorityQueue.isEmpty()) {
            // ä¼˜å…ˆé˜Ÿåˆ—éç©ºæ‰èƒ½å‡ºé˜Ÿ
            ListNode node = priorityQueue.poll();
            // å½“å‰èŠ‚ç‚¹çš„ next æŒ‡é’ˆæŒ‡å‘å‡ºé˜Ÿå…ƒç´ 
            curNode.next = node;
            // å½“å‰æŒ‡é’ˆå‘å‰ç§»åŠ¨ä¸€ä¸ªå…ƒç´ ï¼ŒæŒ‡å‘äº†åˆšåˆšå‡ºé˜Ÿçš„é‚£ä¸ªå…ƒç´ 
            curNode = curNode.next;
            if (curNode.next != null) {
                // åªæœ‰éç©ºèŠ‚ç‚¹æ‰èƒ½åŠ å…¥åˆ°ä¼˜å…ˆé˜Ÿåˆ—ä¸­
                priorityQueue.add(curNode.next);
            }
        }
        return dummyNode.next;
    }

    public static void main(String[] args) {
        Integer[] nums1 = {1, 4, 5};
        Integer[] nums2 = {1, 3, 4};
        Integer[] nums3 = {2, 6};
        ListNode head1 = new ListNode(nums1);
        ListNode head2 = new ListNode(nums2);
        ListNode head3 = new ListNode(nums3);
        ListNode[] lists = new ListNode[3];
        lists[0] = head1;
        lists[1] = head2;
        lists[2] = head3;
        Solution solution = new Solution();
        ListNode mergeKLists = solution.mergeKLists(lists);
        System.out.println(mergeKLists);
    }
}
```

åœ¨æ–‡æœ«é™„ä¸Šäº†ä½¿ç”¨æœ€å°ç´¢å¼•å †è§£å†³è¿™ä¸ªé—®é¢˜çš„ä»£ç ï¼Œç¨æ˜¾å¤æ‚ï¼Œä»…ä¾›å‚è€ƒã€‚

**å¤æ‚åº¦åˆ†æï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘logğ‘˜)O(Nlogâ¡k)ï¼Œè¿™é‡Œ ğ‘N æ˜¯è¿™ ğ‘˜k ä¸ªé“¾è¡¨çš„ç»“ç‚¹æ€»æ•°ï¼Œæ¯ä¸€æ¬¡ä»ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ä¸­é€‰å‡ºä¸€ä¸ªæœ€å°ç»“ç‚¹çš„æ—¶é—´å¤æ‚åº¦æ˜¯ ğ‘‚(logğ‘˜)O(logâ¡k)ï¼Œæ•…æ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(ğ‘logğ‘˜)O(Nlogâ¡k)ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘˜)O(k)ï¼Œä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—éœ€è¦ ğ‘˜k ä¸ªç©ºé—´ï¼Œâ€œç©¿é’ˆå¼•çº¿â€éœ€è¦å¸¸æ•°ä¸ªç©ºé—´ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º ğ‘‚(ğ‘˜)O(k)ã€‚

### æ–¹æ³•äºŒï¼šåˆ†æ²»æ³•

æ ¹æ®ä¹‹å‰å¤„ç†é“¾è¡¨çš„ç»éªŒï¼ˆä¾‹å¦‚ [LeetCode ç¬¬ 206 é¢˜ï¼šåè½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-linked-list/)ï¼‰ï¼Œå¦‚æœæˆ‘ä»¬ä¸æƒ³â€œç©¿é’ˆå¼•çº¿â€ï¼Œé‚£ä¹ˆâ€œé€’å½’â€ã€â€œåˆ†æ²»â€æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ã€‚

ä»£ç ç»“æ„å’Œâ€œå½’å¹¶æ’åºâ€å¯ä»¥è¯´æ˜¯åŒå‡ºä¸€è¾™ï¼š

1ã€å…ˆä¸€åˆ†ä¸ºäºŒï¼Œåˆ†åˆ«â€œé€’å½’åœ°â€è§£å†³äº†ä¸åŸé—®é¢˜åŒç»“æ„ï¼Œä½†è§„æ¨¡æ›´å°çš„ä¸¤ä¸ªå­é—®é¢˜ï¼›

2ã€å†è€ƒè™‘å¦‚ä½•åˆå¹¶ï¼Œè¿™ä¸ªåˆå¹¶çš„è¿‡ç¨‹ä¹Ÿæ˜¯ä¸€ä¸ªé€’å½’æ–¹æ³•ï¼ˆåŒ [LeetCode ç¬¬ 21 é¢˜ï¼šåˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-two-sorted-lists/)ï¼‰ã€‚

Python ä»£ç ï¼š

Python

```Python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        size = len(lists)
        if size == 0:
            return None
        return self.__merge_k_lists(lists, 0, size - 1)

    def __merge_k_lists(self, lists, left, right):
        if left >= right:
            return lists[left]
        mid = left + (right - left) // 2
        listnode1 = self.__merge_k_lists(lists, left, mid)
        listnode2 = self.__merge_k_lists(lists, mid + 1, right)
        return self.__merge_two_sorted_list_node(listnode1, listnode2)

    def __merge_two_sorted_list_node(self, list1, list2):
        if list1 is None:
            return list2
        if list2 is None:
            return list1

        if list1.val < list2.val:
            list1.next = self.__merge_two_sorted_list_node(list1.next, list2)
            return list1
        else:
            list2.next = self.__merge_two_sorted_list_node(list1, list2.next)
            return list2
```

Java ä»£ç ï¼š

Java

```Java
import java.util.Comparator;
import java.util.PriorityQueue;

class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }

    ListNode(Integer[] nums) {
        ListNode currNode = this;
        currNode.val = nums[0];
        for (int i = 1; i < nums.length; i++) {
            currNode.next = new ListNode(nums[i]);
            currNode = currNode.next;
        }
    }

    @Override
    public String toString() {
        ListNode currNode = this;
        StringBuilder s = new StringBuilder();
        while (currNode != null) {
            s.append(currNode.val);
            s.append(" -> ");
            currNode = currNode.next;
        }
        // æœ€åæ·»åŠ ä¸€ä¸ª NULL æ ‡å¿—è¡¨ç¤ºæ·»åŠ åˆ°æœ«å°¾äº†
        s.append("NULL");
        return s.toString();
    }
}

public class Solution {

    public ListNode mergeKLists(ListNode[] lists) {
        int len = lists.length;
        if (len == 0) {
            return null;
        }
        return mergeKLists(lists, 0, len - 1);
    }

    public ListNode mergeKLists(ListNode[] lists, int l, int r) {
        // æ€è€ƒè¿™é‡Œä¸ºä»€ä¹ˆå–ç­‰äºï¼Ÿè¿™æ˜¯å› ä¸ºæ ¹æ®ä¸‹æ–‡å¯¹ mergeKLists çš„é€’å½’è°ƒç”¨æƒ…å†µï¼ŒåŒºé—´æœ€çª„çš„æ—¶å€™ï¼Œåªå¯èƒ½æ˜¯å·¦å³ç«¯ç‚¹é‡åˆ
        if (l == r) {
            return lists[l];
        }
        int mid = (r - l) / 2 + l;
        ListNode l1 = mergeKLists(lists, l, mid);
        ListNode l2 = mergeKLists(lists, mid + 1, r);
        return mergeTwoSortedListNode(l1, l2);
    }

    private ListNode mergeTwoSortedListNode(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoSortedListNode(l1.next, l2);
            return l1;
        }
        l2.next = mergeTwoSortedListNode(l1, l2.next);
        return l2;
    }
}
```

**å¤æ‚åº¦åˆ†æï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘logğ‘˜)O(Nlogâ¡k)ï¼Œè¿™é‡Œ ğ‘N æ˜¯è¿™ ğ‘˜k ä¸ªé“¾è¡¨çš„ç»“ç‚¹æ€»æ•°ï¼Œğ‘˜k ä¸ªé“¾è¡¨äºŒåˆ†æ˜¯å¯¹æ•°çº§åˆ«çš„ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(1)O(1)ï¼Œåˆå¹¶ä¸¤ä¸ªæ’åºé“¾è¡¨éœ€è¦â€œç©¿é’ˆå¼•çº¿â€çš„æŒ‡é’ˆæ•°æ˜¯å¸¸æ•°ä¸ªçš„ã€‚

------

### é™„ï¼šæ–¹æ³•ä¸€çš„è¡¥å……ï¼šä½¿ç”¨æœ€å°ç´¢å¼•å †

ä¸‹é¢ä½¿ç”¨è‡ªå·±ç¼–å†™æœ€å°ç´¢å¼•å †å®Œæˆï¼Œä»£ç æ¯”è¾ƒé•¿ï¼Œä»…ä¾›å‚è€ƒã€‚

Python ä»£ç ï¼š





Python

```Python
class IndexMinHeap:

    def __init__(self, capacity):
        self.data = [0 for _ in range(capacity + 1)]
        self.indexes = [0 for _ in range(capacity + 1)]
        self.reverse = [0 for _ in range(capacity + 1)]

        self.count = 0
        self.capacity = capacity

    def size(self):
        return self.count

    def is_empty(self):
        return self.count == 0

    # æ­¤æ—¶ insert è¦ç»™ä¸€ä¸ªç´¢å¼•ä½ç½®
    def insert(self, i, item):
        if self.count + 1 > self.capacity:
            raise Exception('å †çš„å®¹é‡ä¸å¤Ÿäº†')

        i += 1
        self.data[i] = item

        self.indexes[self.count + 1] = i
        # æ³¨æ„ï¼šåå‘æŸ¥æ‰¾è¡¨æ˜¯å¦‚ä½•æ›´æ–°çš„
        self.reverse[i] = self.count + 1

        self.count += 1
        self.__shift_up(self.count)

    def __shift_up(self, k):
        while k > 1 and self.data[self.indexes[k // 2]] > self.data[self.indexes[k]]:
            self.indexes[k // 2], self.indexes[k] = self.indexes[k], self.indexes[k // 2]
            # åªè¦ç´¢å¼•å‘ç”Ÿäº¤æ¢ï¼Œåå‘æŸ¥æ‰¾è¡¨ä¹Ÿè¦æ›´æ–°
            self.reverse[self.indexes[k // 2]] = k // 2
            self.reverse[self.indexes[k]] = k

            k //= 2

    def extract_min(self):
        if self.count == 0:
            raise Exception('å †é‡Œæ²¡æœ‰å¯ä»¥å–å‡ºçš„å…ƒç´ ')
        # é‡Œé¢å¥—ä¸€å±‚ indexes
        ret = self.data[self.indexes[1]]
        # äº¤æ¢çš„æ˜¯ç´¢å¼•
        self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]
        # åªè¦ç´¢å¼•å‘ç”Ÿäº¤æ¢ï¼Œåå‘æŸ¥æ‰¾è¡¨ä¹Ÿè¦æ›´æ–°
        self.reverse[self.indexes[1]] = 1
        self.reverse[self.indexes[self.count]] = self.count

        # è®¾ç½®å¤±æ•ˆ
        self.reverse[self.indexes[self.count]] = 0

        self.count -= 1
        self.__shift_down(1)
        return ret

    def __shift_down(self, k):
        while 2 * k <= self.count:
            j = 2 * k
            # æ¯”è¾ƒçš„æ˜¯ data ï¼Œäº¤æ¢çš„æ˜¯ indexes
            if j + 1 <= self.count and self.data[self.indexes[j + 1]] < self.data[self.indexes[j]]:
                j = j + 1
            if self.data[self.indexes[k]] <= self.data[self.indexes[j]]:
                break
            self.indexes[k], self.indexes[j] = self.indexes[j], self.indexes[k]

            # åªè¦ç´¢å¼•å‘ç”Ÿäº¤æ¢ï¼Œåå‘æŸ¥æ‰¾è¡¨ä¹Ÿè¦æ›´æ–°
            self.reverse[self.indexes[k]] = k
            self.reverse[self.indexes[j]] = j

            k = j

    # æ–°å¢æ–¹æ³•
    def extract_min_index(self):
        assert self.count > 0
        # å‡ 1 æ˜¯ä¸ºäº†ç¬¦åˆç”¨æˆ·è§†è§’
        ret = self.indexes[1] - 1
        self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]

        # åªè¦ç´¢å¼•å‘ç”Ÿäº¤æ¢ï¼Œåå‘æŸ¥æ‰¾è¡¨ä¹Ÿè¦æ›´æ–°
        self.reverse[self.indexes[1]] = 1
        self.reverse[self.indexes[self.count]] = self.count

        # è®¾ç½®å¤±æ•ˆ
        self.reverse[self.indexes[self.count]] = 0

        self.count -= 1
        self.__shift_down(1)
        return ret

    # æ–°å¢æ–¹æ³•
    def get_min_index(self):
        return self.indexes[1] - 1

    # æ–°å¢æ–¹æ³•
    def get_item(self, i):
        # å†…éƒ¨æ•°ç»„çš„ç´¢å¼•æ¯”ç”¨æˆ·è§†è§’å¤š 1
        return self.data[i + 1]

    # æ–°å¢æ–¹æ³•
    def change(self, i, new_item):
        # æŠŠç”¨æˆ·è§†è§’æ”¹æˆå†…éƒ¨ç´¢å¼•
        i += 1
        self.data[i] = new_item

        # é‡ç‚¹ï¼šä¸‹é¢è¿™ä¸€æ­¥æ˜¯æ‰¾åŸæ¥æ•°ç»„ä¸­ç´¢å¼•æ˜¯ i çš„å…ƒç´ 
        # åœ¨ç´¢å¼•æ•°ç»„ä¸­çš„ç´¢å¼•æ˜¯å‡ ï¼Œè¿™æ˜¯ä¸€ä¸ªå”¯ä¸€å€¼ï¼Œæ‰¾åˆ°å³è¿”å›
        # ä¼˜åŒ–ï¼šå¯ä»¥å¼•å…¥åå‘æŸ¥æ‰¾æŠ€æœ¯ä¼˜åŒ–
        j = self.reverse[i]

        self.__shift_down(j)
        self.__shift_up(j)


# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists: 'List[ListNode]') -> 'ListNode':

        # è¿™ä¸€æ­¥æ˜¯å»æ‰ç©ºé“¾è¡¨
        new_lists = []
        for i in range(len(lists)):
            if lists[i]:
                new_lists.append(lists[i])

        size = len(new_lists)
        index_min_heap = IndexMinHeap(size)
        for i in range(size):
            index_min_heap.insert(i,new_lists[i].val)

        dummy = ListNode(-1)
        cur = dummy
        while index_min_heap.size() > 0:
            index = index_min_heap.get_min_index()

            print(index, index_min_heap.data,new_lists[index].val)
            cur.next = ListNode(new_lists[index].val)
            cur = cur.next
            if new_lists[index].next is None:
                # å¦‚æœåé¢æ²¡æœ‰å…ƒç´ ï¼Œå°±å¯ä»¥åˆ æ‰äº†
                index_min_heap.extract_min_index()
            else:
                index_min_heap.change(index, new_lists[index].next.val)
                new_lists[index] = new_lists[index].next
        return dummy.next


def create_linked_list(nums):
    if len(nums) == 0:
        return None
    head = ListNode(nums[0])
    cur = head
    for i in range(1, len(nums)):
        cur.next = ListNode(nums[i])
        cur = cur.next
    return head


def print_linked_list(list_node):
    if list_node is None:
        return

    cur = list_node
    while cur:
        print(cur.val, '->', end=' ')
        cur = cur.next
    print('null')


if __name__ == '__main__':
    sorted_linked1 = create_linked_list([i for i in range(1, 20, 3)])
    sorted_linked2 = create_linked_list([i for i in range(2, 20, 3)])
    sorted_linked3 = create_linked_list([i for i in range(3, 20, 3)])

    print_linked_list(sorted_linked1)
    print_linked_list(sorted_linked2)
    print_linked_list(sorted_linked3)

    solution = Solution()

    result = solution.mergeKLists(lists=[sorted_linked1, sorted_linked2, sorted_linked3])
    print_linked_list(result)

    sorted_linked1 = create_linked_list([1,2,3])
    sorted_linked2 = create_linked_list([4,5,6,7])
    sorted_linked3 = create_linked_list([])

    solution = Solution()

    result = solution.mergeKLists(lists=[sorted_linked1, sorted_linked2,sorted_linked3])
    print_linked_list(result)
```

### LeetCode ç¬¬ 23 é¢˜ï¼šå½’å¹¶å¤šä¸ªæœ‰åºé“¾è¡¨

ä¼ é€é—¨ï¼š[23. åˆå¹¶Kä¸ªæ’åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/)ã€‚

> åˆå¹¶ *k* ä¸ªæ’åºé“¾è¡¨ï¼Œè¿”å›åˆå¹¶åçš„æ’åºé“¾è¡¨ã€‚è¯·åˆ†æå’Œæè¿°ç®—æ³•çš„å¤æ‚åº¦ã€‚
>
> **ç¤ºä¾‹:**
>
> ```
> è¾“å…¥:
> [
> 1->4->5,
> 1->3->4,
> 2->6
> ]
> è¾“å‡º: 1->1->2->3->4->4->5->6
> ```

æ€è·¯1ï¼šä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ã€‚

é¦–å…ˆè¦å¤ä¹ ä¸€ä¸‹ Python ä¸­ä¼˜å…ˆé˜Ÿåˆ—çš„ä½¿ç”¨ã€‚

Python ä»£ç ï¼š

python

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        import heapq
        l = []
        size = len(lists)

        for index in range(size):
            if lists[index]:
                heapq.heappush(l, (lists[index].val, index))

        dummy_node = ListNode(-1)
        cur = dummy_node

        while l:
            _, index = heapq.heappop(l)

            head = lists[index]

            cur.next = head
            cur = cur.next
            if head.next:
                heapq.heappush(l, (head.next.val, index))
                lists[index] = head.next
                head.next = None

        return dummy_node.next
```

æ€è·¯2ï¼šä½¿ç”¨åˆ†æ²»

å‚è€ƒèµ„æ–™ï¼šhttps://liweiwei1419.github.io/leetcode-solution/leetcode-0023-merge-k-sorted-lists/

Python ä»£ç ï¼š

python

```python
# 23. åˆå¹¶Kä¸ªæ’åºé“¾è¡¨
# åˆå¹¶ k ä¸ªæ’åºé“¾è¡¨ï¼Œè¿”å›åˆå¹¶åçš„æ’åºé“¾è¡¨ã€‚è¯·åˆ†æå’Œæè¿°ç®—æ³•çš„å¤æ‚åº¦ã€‚

# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


# æ€è·¯ï¼šåˆ†æ²»æ³•ä¸ä¼˜å…ˆé˜Ÿåˆ—


class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """

        size = len(lists)
        if size == 0:
            return None
        return self.__merge_k_lists(lists, 0, size - 1)

    def __merge_k_lists(self, lists, left, right):
        if left >= right:
            return lists[left]
        mid = left + (right - left) // 2
        listnode1 = self.__merge_k_lists(lists, left, mid)
        listnode2 = self.__merge_k_lists(lists, mid + 1, right)
        return self.__merge_two_sorted_list_node(listnode1, listnode2)

    def __merge_two_sorted_list_node(self, list1, list2):
        if list1 is None:
            return list2
        if list2 is None:
            return list1

        if list1.val < list2.val:
            list1.next = self.__merge_two_sorted_list_node(list1.next, list2)
            return list1
        else:
            list2.next = self.__merge_two_sorted_list_node(list1, list2.next)
            return list2
```

------

# ç¬¬ 23 é¢˜ï¼šâ€œåˆå¹¶ K ä¸ªæ’åºé“¾è¡¨â€é¢˜è§£

é¢˜è§£åœ°å€ï¼š[è´ªå¿ƒç®—æ³•ã€ä¼˜å…ˆé˜Ÿåˆ— + åˆ†æ²»æ³•ï¼ˆPython ä»£ç ã€Java ä»£ç ï¼‰](https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/tan-xin-suan-fa-you-xian-dui-lie-fen-zhi-fa-python/)ã€‚

è¯´æ˜ï¼šæ–‡æœ¬é¦–å‘åœ¨åŠ›æ‰£çš„é¢˜è§£ç‰ˆå—ï¼Œæ›´æ–°ä¹Ÿä¼šåœ¨ç¬¬ 1 æ—¶é—´åœ¨ä¸Šé¢çš„ç½‘ç«™ä¸­æ›´æ–°ï¼Œè¿™ç¯‡æ–‡ç« åªæ˜¯ä¸Šé¢çš„æ–‡ç« çš„ä¸€ä¸ªå¿«ç…§ï¼Œæ‚¨å¯ä»¥ç‚¹å‡»ä¸Šé¢çš„é“¾æ¥çœ‹åˆ°å…¶ä»–ç½‘å‹å¯¹æœ¬æ–‡çš„è¯„è®ºã€‚

ä¼ é€é—¨ï¼š[23. åˆå¹¶Kä¸ªæ’åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/)ã€‚

> åˆå¹¶ k ä¸ªæ’åºé“¾è¡¨ï¼Œè¿”å›åˆå¹¶åçš„æ’åºé“¾è¡¨ã€‚è¯·åˆ†æå’Œæè¿°ç®—æ³•çš„å¤æ‚åº¦ã€‚
>
> ç¤ºä¾‹:
>
> è¾“å…¥:
> [
> 1->4->5,
> 1->3->4,
> 2->6
> ]
> è¾“å‡º: 1->1->2->3->4->4->5->6
>
> æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
> é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/merge-k-sorted-lists
> è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

## è´ªå¿ƒç®—æ³•ã€ä¼˜å…ˆé˜Ÿåˆ— + åˆ†æ²»æ³•ï¼ˆPython ä»£ç ã€Java ä»£ç ï¼‰

### æ–¹æ³•ä¸€ï¼šè´ªå¿ƒç®—æ³•ã€ä¼˜å…ˆé˜Ÿåˆ—

æ€è·¯åˆ†æï¼š

1ã€ç”±äºæ˜¯ ğ‘˜k ä¸ªæ’åºé“¾è¡¨ï¼Œé‚£ä¹ˆè¿™ ğ‘˜k ä¸ªæ’åºçš„é“¾è¡¨**å¤´ç»“ç‚¹**ä¸­ `val` **æœ€å°**çš„ç»“ç‚¹å°±æ˜¯åˆå¹¶ä»¥åçš„é“¾è¡¨ä¸­æœ€å°çš„ç»“ç‚¹ï¼›

2ã€æœ€å°ç»“ç‚¹æ‰€åœ¨çš„é“¾è¡¨çš„å¤´ç»“ç‚¹å°±è¦æ›´æ–°äº†ï¼Œæ›´æ–°æˆæœ€å°ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œæ­¤æ—¶è¿˜æ˜¯è¿™ ğ‘˜k ä¸ªé“¾è¡¨ï¼Œè¿™ ğ‘˜k ä¸ªæ’åºçš„é“¾è¡¨**å¤´ç»“ç‚¹**ä¸­ `val` **æœ€å°**çš„ç»“ç‚¹å°±æ˜¯åˆå¹¶ä»¥åçš„é“¾è¡¨ä¸­ç¬¬ 22 å°çš„ç»“ç‚¹ã€‚

å†™åˆ°è¿™é‡Œï¼Œæˆ‘æƒ³ä½ åº”è¯¥å·®ä¸å¤šæ˜ç™½äº†ï¼Œæˆ‘ä»¬æ¯ä¸€æ¬¡éƒ½ä»è¿™ ğ‘˜k ä¸ªæ’åºçš„é“¾è¡¨**å¤´ç»“ç‚¹**ä¸­æ‹¿å‡º `val` æœ€å°çš„ç»“ç‚¹â€œç©¿é’ˆå¼•çº¿â€æˆæ–°çš„é“¾è¡¨ï¼Œè¿™ä¸ªé“¾è¡¨å°±æ˜¯é¢˜ç›®è¦æ±‚çš„â€œåˆå¹¶åçš„æ’åºé“¾è¡¨â€ã€‚â€œå±€éƒ¨æœ€ä¼˜ï¼Œå…¨å±€å°±æœ€ä¼˜â€ï¼Œè¿™ä¸å°±æ˜¯è´ªå¿ƒç®—æ³•çš„æ€æƒ³å—ã€‚

è¿™é‡Œæˆ‘ä»¬ä¸¾ç”Ÿæ´»ä¸­çš„ä¾‹å­æ¥ç†è§£è¿™ä¸ªæ€è·¯ã€‚

> å‡è®¾ä½ æ˜¯ä¸€åä½“è‚²è€å¸ˆï¼Œæœ‰ 33 ä¸ªç­çš„å­¦ç”Ÿï¼Œä»–ä»¬å·²ç»æŒ‰ç…§èº«é«˜ä»çŸ®åˆ°é«˜æ’å¥½æˆäº† 33 åˆ—çºµé˜Ÿï¼Œç°åœ¨è¦æŠŠè¿™ 33 ä¸ªç­çš„å­¦ç”Ÿä¹ŸæŒ‰ç…§èº«é«˜ä»çŸ®åˆ°é«˜æ’åˆ— 11 åˆ—çºµé˜Ÿã€‚æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆåšï¼š
>
> 1ã€è®© 33 ä¸ªç­çš„å­¦ç”ŸæŒ‰åˆ—ç«™åœ¨ä½ çš„é¢å‰ï¼Œè¿™æ—¶ä½ èƒ½çœ‹åˆ°ç«™åœ¨é˜Ÿé¦–çš„å­¦ç”Ÿçš„å…¨èº«ï¼›
> 2ã€æ¯ä¸€æ¬¡é˜Ÿé¦–çš„ 33 ååŒå­¦ï¼Œè¯·æœ€çŸ®çš„åŒå­¦å‡ºåˆ—åˆ°â€œé˜Ÿä¼4â€ï¼ˆå³æˆ‘ä»¬æœ€ç»ˆè®¤ä¸ºæ’å¥½åºçš„é˜Ÿåˆ—ï¼‰ï¼Œå‡ºåˆ—çš„è¿™ä¸€åˆ—çš„åé¢çš„æ‰€æœ‰åŒå­¦éƒ½å‘å‰èµ°ä¸€æ­¥ï¼ˆå…¶å®èµ°ä¸èµ°éƒ½è¡Œï¼Œåªè¦ä½ èƒ½æ¯”è¾ƒå‡ºç«™åœ¨ä½ é¢å‰çš„ 3 ä½åœ¨é˜Ÿé¦–çš„åŒå­¦åŒå­¦çš„é«˜çŸ®å³å¯ï¼‰ï¼›
> 3ã€é‡å¤ç¬¬ 2 æ­¥ï¼Œç›´åˆ° 33 ä¸ªç­çš„åŒå­¦å…¨éƒ¨å‡ºåˆ—å®Œæ¯•ã€‚

å…·ä½“å®ç°çš„æ—¶å€™ï¼Œâ€œæ¯ä¸€æ¬¡é˜Ÿé¦–çš„ 33 ååŒå­¦ï¼Œè¯·æœ€çŸ®çš„åŒå­¦å‡ºåˆ—â€è¿™ä»¶äº‹æƒ…å¯ä»¥äº¤ç»™**ä¼˜å…ˆé˜Ÿåˆ—**ï¼ˆæœ€å°å †ã€æœ€å°ç´¢å¼•å †å‡å¯ï¼‰å»å®Œæˆã€‚åœ¨è¿ç»­çš„ä¸¤æ¬¡å‡ºé˜Ÿä¹‹é—´å®Œæˆâ€œç©¿é’ˆå¼•çº¿â€çš„å·¥ä½œã€‚

ä¸‹é¢çš„å›¾è§£é‡Šäº†ä¸Šé¢çš„æ€è·¯ã€‚

ï¼ˆæ¸©é¦¨æç¤ºï¼šä¸‹é¢çš„å¹»ç¯ç‰‡ä¸­ï¼Œæœ‰å‡ é¡µä¸Šæœ‰è¾ƒå¤šçš„æ–‡å­—ï¼Œå¯èƒ½éœ€è¦æ‚¨åœç•™ä¸€ä¸‹ï¼Œå¯ä»¥ç‚¹å‡»å³ä¸‹è§’çš„åé€€ â€œ|â—€â€ æˆ–è€…å‰è¿› â€œâ–¶|â€ æŒ‰é’®æ§åˆ¶å¹»ç¯ç‰‡çš„æ’­æ”¾ã€‚ï¼‰

Python3 ä»£ç ï¼šPython3 çš„ `heapq` æ¨¡å—ä¼ å…¥çš„ `tuple` å¯¹è±¡é‡Œé¢ä¸èƒ½æœ‰å¼•ç”¨å¯¹è±¡ï¼Œå°±åªå¥½ä¼ ä¸€ä¸ªç´¢å¼•è¿›å»äº†ã€‚
Java ä»£ç ï¼šä¿ç•™äº†ä¸€äº›è°ƒè¯•ä»£ç ã€‚

è¯´æ˜ï¼šä¸‹é¢çš„é€‰é¡¹å¡ä¸­ï¼Œç¬¬ 1 ä¸ª Python ä»£ç æ˜¯åœ¨ Python3 ä¸‹æäº¤çš„ä»£ç ï¼Œç¬¬ 2 ä¸ª Python ä»£ç æ˜¯åœ¨ Python2 ä¸‹æäº¤çš„ä»£ç ã€‚

**å‚è€ƒä»£ç  1**ï¼š

Python ä»£ç ï¼š

Python

```Python
# Python3 ä¸‹çš„ä»£ç 
from typing import List
import heapq

class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        l = []
        size = len(lists)

        for index in range(size):
            # é’ˆå¯¹ä¸€äº›ç‰¹æ®Šçš„æµ‹è¯•ç”¨ä¾‹ï¼Œæœ‰çš„é“¾è¡¨å¯èƒ½æ˜¯ç©ºé“¾è¡¨
            if lists[index]:
                heapq.heappush(l, (lists[index].val, index))

        dummy_node = ListNode(-1)
        cur = dummy_node

        while l:
            _, index = heapq.heappop(l)

            # å®šä½åˆ°æ­¤æ—¶åº”è¯¥å‡ºåˆ—çš„é‚£ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹
            head = lists[index]
            # å¼€å§‹â€œç©¿é’ˆå¼•çº¿â€
            cur.next = head
            cur = cur.next
            # åŒæ ·ä¸è¦å¿˜è®°åˆ¤æ–­åˆ°é“¾è¡¨æœ«å°¾ç»“ç‚¹çš„æ—¶å€™
            if head.next:
                # åˆšåˆšå‡ºåˆ—çš„é‚£ä¸ªé“¾è¡¨çš„ä¸‹ä¸€ä¸ªç»“ç‚¹æˆä¸ºæ–°çš„é“¾è¡¨å¤´ç»“ç‚¹åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—
                heapq.heappush(l, (head.next.val, index))
                # åˆ‡æ–­åˆšåˆšå‡ºåˆ—çš„é‚£ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹å¼•ç”¨
                lists[index] = head.next
                head.next = None
        return dummy_node.next
```

Python ä»£ç ï¼š

Python

```Python
# Python2 ä¸‹çš„ä»£ç 
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        import heapq
        l = []
        for head in lists:
            if head:
                heapq.heappush(l, (head.val, head))
        dummy_node = ListNode(-1)
        cur = dummy_node

        while l:
            _, head = heapq.heappop(l)
            cur.next = head
            cur = cur.next
            if head.next:
                heapq.heappush(l, (head.next.val, head.next))

        return dummy_node.next
```

Java ä»£ç ï¼š

Java

```Java
import java.util.Comparator;
import java.util.PriorityQueue;

class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }

    ListNode(Integer[] nums) {
        ListNode currNode = this;
        currNode.val = nums[0];
        for (int i = 1; i < nums.length; i++) {
            currNode.next = new ListNode(nums[i]);
            currNode = currNode.next;
        }
    }

    @Override
    public String toString() {
        ListNode currNode = this;
        StringBuilder s = new StringBuilder();
        while (currNode != null) {
            s.append(currNode.val);
            s.append(" -> ");
            currNode = currNode.next;
        }
        // æœ€åæ·»åŠ ä¸€ä¸ª NULL æ ‡å¿—è¡¨ç¤ºæ·»åŠ åˆ°æœ«å°¾äº†
        s.append("NULL");
        return s.toString();
    }
}

public class Solution {

    public ListNode mergeKLists(ListNode[] lists) {
        int len = lists.length;
        if (len == 0) {
            return null;
        }
        PriorityQueue priorityQueue = new PriorityQueue<>(len, Comparator.comparingInt(a -> a.val));
        ListNode dummyNode = new ListNode(-1);
        ListNode curNode = dummyNode;
        for (ListNode list : lists) {
            if (list != null) {
                // è¿™ä¸€æ­¥å¾ˆå…³é”®ï¼Œä¸èƒ½ä¹Ÿæ²¡æœ‰å¿…è¦å°†ç©ºå¯¹è±¡æ·»åŠ åˆ°ä¼˜å…ˆé˜Ÿåˆ—ä¸­
                priorityQueue.add(list);
            }
        }
        while (!priorityQueue.isEmpty()) {
            // ä¼˜å…ˆé˜Ÿåˆ—éç©ºæ‰èƒ½å‡ºé˜Ÿ
            ListNode node = priorityQueue.poll();
            // å½“å‰èŠ‚ç‚¹çš„ next æŒ‡é’ˆæŒ‡å‘å‡ºé˜Ÿå…ƒç´ 
            curNode.next = node;
            // å½“å‰æŒ‡é’ˆå‘å‰ç§»åŠ¨ä¸€ä¸ªå…ƒç´ ï¼ŒæŒ‡å‘äº†åˆšåˆšå‡ºé˜Ÿçš„é‚£ä¸ªå…ƒç´ 
            curNode = curNode.next;
            if (curNode.next != null) {
                // åªæœ‰éç©ºèŠ‚ç‚¹æ‰èƒ½åŠ å…¥åˆ°ä¼˜å…ˆé˜Ÿåˆ—ä¸­
                priorityQueue.add(curNode.next);
            }
        }
        return dummyNode.next;
    }

    public static void main(String[] args) {
        Integer[] nums1 = {1, 4, 5};
        Integer[] nums2 = {1, 3, 4};
        Integer[] nums3 = {2, 6};
        ListNode head1 = new ListNode(nums1);
        ListNode head2 = new ListNode(nums2);
        ListNode head3 = new ListNode(nums3);
        ListNode[] lists = new ListNode[3];
        lists[0] = head1;
        lists[1] = head2;
        lists[2] = head3;
        Solution solution = new Solution();
        ListNode mergeKLists = solution.mergeKLists(lists);
        System.out.println(mergeKLists);
    }
}
```

åœ¨æ–‡æœ«é™„ä¸Šäº†ä½¿ç”¨æœ€å°ç´¢å¼•å †è§£å†³è¿™ä¸ªé—®é¢˜çš„ä»£ç ï¼Œç¨æ˜¾å¤æ‚ï¼Œä»…ä¾›å‚è€ƒã€‚

**å¤æ‚åº¦åˆ†æï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘logğ‘˜)O(Nlogâ¡k)ï¼Œè¿™é‡Œ ğ‘N æ˜¯è¿™ ğ‘˜k ä¸ªé“¾è¡¨çš„ç»“ç‚¹æ€»æ•°ï¼Œæ¯ä¸€æ¬¡ä»ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ä¸­é€‰å‡ºä¸€ä¸ªæœ€å°ç»“ç‚¹çš„æ—¶é—´å¤æ‚åº¦æ˜¯ ğ‘‚(logğ‘˜)O(logâ¡k)ï¼Œæ•…æ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(ğ‘logğ‘˜)O(Nlogâ¡k)ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘˜)O(k)ï¼Œä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—éœ€è¦ ğ‘˜k ä¸ªç©ºé—´ï¼Œâ€œç©¿é’ˆå¼•çº¿â€éœ€è¦å¸¸æ•°ä¸ªç©ºé—´ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º ğ‘‚(ğ‘˜)O(k)ã€‚

### æ–¹æ³•äºŒï¼šåˆ†æ²»æ³•

æ ¹æ®ä¹‹å‰å¤„ç†é“¾è¡¨çš„ç»éªŒï¼ˆä¾‹å¦‚ [LeetCode ç¬¬ 206 é¢˜ï¼šåè½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-linked-list/)ï¼‰ï¼Œå¦‚æœæˆ‘ä»¬ä¸æƒ³â€œç©¿é’ˆå¼•çº¿â€ï¼Œé‚£ä¹ˆâ€œé€’å½’â€ã€â€œåˆ†æ²»â€æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ã€‚

ä»£ç ç»“æ„å’Œâ€œå½’å¹¶æ’åºâ€å¯ä»¥è¯´æ˜¯åŒå‡ºä¸€è¾™ï¼š

1ã€å…ˆä¸€åˆ†ä¸ºäºŒï¼Œåˆ†åˆ«â€œé€’å½’åœ°â€è§£å†³äº†ä¸åŸé—®é¢˜åŒç»“æ„ï¼Œä½†è§„æ¨¡æ›´å°çš„ä¸¤ä¸ªå­é—®é¢˜ï¼›

2ã€å†è€ƒè™‘å¦‚ä½•åˆå¹¶ï¼Œè¿™ä¸ªåˆå¹¶çš„è¿‡ç¨‹ä¹Ÿæ˜¯ä¸€ä¸ªé€’å½’æ–¹æ³•ï¼ˆåŒ [LeetCode ç¬¬ 21 é¢˜ï¼šåˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-two-sorted-lists/)ï¼‰ã€‚

**å‚è€ƒä»£ç  2**ï¼š

Python ä»£ç ï¼š

Python

```Python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        size = len(lists)
        if size == 0:
            return None
        return self.__merge_k_lists(lists, 0, size - 1)

    def __merge_k_lists(self, lists, left, right):
        if left >= right:
            return lists[left]
        mid = left + (right - left) // 2
        listnode1 = self.__merge_k_lists(lists, left, mid)
        listnode2 = self.__merge_k_lists(lists, mid + 1, right)
        return self.__merge_two_sorted_list_node(listnode1, listnode2)

    def __merge_two_sorted_list_node(self, list1, list2):
        if list1 is None:
            return list2
        if list2 is None:
            return list1

        if list1.val < list2.val:
            list1.next = self.__merge_two_sorted_list_node(list1.next, list2)
            return list1
        else:
            list2.next = self.__merge_two_sorted_list_node(list1, list2.next)
            return list2
```

Java ä»£ç ï¼š

Java

```Java
import java.util.Comparator;
import java.util.PriorityQueue;

class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }

    ListNode(Integer[] nums) {
        ListNode currNode = this;
        currNode.val = nums[0];
        for (int i = 1; i < nums.length; i++) {
            currNode.next = new ListNode(nums[i]);
            currNode = currNode.next;
        }
    }

    @Override
    public String toString() {
        ListNode currNode = this;
        StringBuilder s = new StringBuilder();
        while (currNode != null) {
            s.append(currNode.val);
            s.append(" -> ");
            currNode = currNode.next;
        }
        // æœ€åæ·»åŠ ä¸€ä¸ª NULL æ ‡å¿—è¡¨ç¤ºæ·»åŠ åˆ°æœ«å°¾äº†
        s.append("NULL");
        return s.toString();
    }
}

public class Solution {

    public ListNode mergeKLists(ListNode[] lists) {
        int len = lists.length;
        if (len == 0) {
            return null;
        }
        return mergeKLists(lists, 0, len - 1);
    }

    public ListNode mergeKLists(ListNode[] lists, int l, int r) {
        // æ€è€ƒè¿™é‡Œä¸ºä»€ä¹ˆå–ç­‰äºï¼Ÿè¿™æ˜¯å› ä¸ºæ ¹æ®ä¸‹æ–‡å¯¹ mergeKLists çš„é€’å½’è°ƒç”¨æƒ…å†µï¼ŒåŒºé—´æœ€çª„çš„æ—¶å€™ï¼Œåªå¯èƒ½æ˜¯å·¦å³ç«¯ç‚¹é‡åˆ
        if (l == r) {
            return lists[l];
        }
        int mid = (r - l) / 2 + l;
        ListNode l1 = mergeKLists(lists, l, mid);
        ListNode l2 = mergeKLists(lists, mid + 1, r);
        return mergeTwoSortedListNode(l1, l2);
    }

    private ListNode mergeTwoSortedListNode(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoSortedListNode(l1.next, l2);
            return l1;
        }
        l2.next = mergeTwoSortedListNode(l1, l2.next);
        return l2;
    }
}
```

**å¤æ‚åº¦åˆ†æï¼š**

- æ—¶é—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘logğ‘˜)O(Nlogâ¡k)ï¼Œè¿™é‡Œ ğ‘N æ˜¯è¿™ ğ‘˜k ä¸ªé“¾è¡¨çš„ç»“ç‚¹æ€»æ•°ï¼Œğ‘˜k ä¸ªé“¾è¡¨äºŒåˆ†æ˜¯å¯¹æ•°çº§åˆ«çš„ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(1)O(1)ï¼Œåˆå¹¶ä¸¤ä¸ªæ’åºé“¾è¡¨éœ€è¦â€œç©¿é’ˆå¼•çº¿â€çš„æŒ‡é’ˆæ•°ä¸ºå¸¸æ•°ã€‚

------

### é™„ï¼šæ–¹æ³•ä¸€çš„è¡¥å……ï¼šä½¿ç”¨æœ€å°ç´¢å¼•å †

ä¸‹é¢ä½¿ç”¨è‡ªå·±ç¼–å†™æœ€å°ç´¢å¼•å †å®Œæˆï¼Œä»£ç æ¯”è¾ƒé•¿ï¼Œä»…ä¾›å‚è€ƒã€‚

**å‚è€ƒä»£ç **ï¼š

Python ä»£ç ï¼š

Python

```Python
class IndexMinHeap:

    def __init__(self, capacity):
        self.data = [0 for _ in range(capacity + 1)]
        self.indexes = [0 for _ in range(capacity + 1)]
        self.reverse = [0 for _ in range(capacity + 1)]

        self.count = 0
        self.capacity = capacity

    def size(self):
        return self.count

    def is_empty(self):
        return self.count == 0

    # æ­¤æ—¶ insert è¦ç»™ä¸€ä¸ªç´¢å¼•ä½ç½®
    def insert(self, i, item):
        if self.count + 1 > self.capacity:
            raise Exception('å †çš„å®¹é‡ä¸å¤Ÿäº†')

        i += 1
        self.data[i] = item

        self.indexes[self.count + 1] = i
        # æ³¨æ„ï¼šåå‘æŸ¥æ‰¾è¡¨æ˜¯å¦‚ä½•æ›´æ–°çš„
        self.reverse[i] = self.count + 1

        self.count += 1
        self.__shift_up(self.count)

    def __shift_up(self, k):
        while k > 1 and self.data[self.indexes[k // 2]] > self.data[self.indexes[k]]:
            self.indexes[k // 2], self.indexes[k] = self.indexes[k], self.indexes[k // 2]
            # åªè¦ç´¢å¼•å‘ç”Ÿäº¤æ¢ï¼Œåå‘æŸ¥æ‰¾è¡¨ä¹Ÿè¦æ›´æ–°
            self.reverse[self.indexes[k // 2]] = k // 2
            self.reverse[self.indexes[k]] = k

            k //= 2

    def extract_min(self):
        if self.count == 0:
            raise Exception('å †é‡Œæ²¡æœ‰å¯ä»¥å–å‡ºçš„å…ƒç´ ')
        # é‡Œé¢å¥—ä¸€å±‚ indexes
        ret = self.data[self.indexes[1]]
        # äº¤æ¢çš„æ˜¯ç´¢å¼•
        self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]
        # åªè¦ç´¢å¼•å‘ç”Ÿäº¤æ¢ï¼Œåå‘æŸ¥æ‰¾è¡¨ä¹Ÿè¦æ›´æ–°
        self.reverse[self.indexes[1]] = 1
        self.reverse[self.indexes[self.count]] = self.count

        # è®¾ç½®å¤±æ•ˆ
        self.reverse[self.indexes[self.count]] = 0

        self.count -= 1
        self.__shift_down(1)
        return ret

    def __shift_down(self, k):
        while 2 * k <= self.count:
            j = 2 * k
            # æ¯”è¾ƒçš„æ˜¯ data ï¼Œäº¤æ¢çš„æ˜¯ indexes
            if j + 1 <= self.count and self.data[self.indexes[j + 1]] < self.data[self.indexes[j]]:
                j = j + 1
            if self.data[self.indexes[k]] <= self.data[self.indexes[j]]:
                break
            self.indexes[k], self.indexes[j] = self.indexes[j], self.indexes[k]

            # åªè¦ç´¢å¼•å‘ç”Ÿäº¤æ¢ï¼Œåå‘æŸ¥æ‰¾è¡¨ä¹Ÿè¦æ›´æ–°
            self.reverse[self.indexes[k]] = k
            self.reverse[self.indexes[j]] = j

            k = j

    # æ–°å¢æ–¹æ³•
    def extract_min_index(self):
        assert self.count > 0
        # å‡ 1 æ˜¯ä¸ºäº†ç¬¦åˆç”¨æˆ·è§†è§’
        ret = self.indexes[1] - 1
        self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]

        # åªè¦ç´¢å¼•å‘ç”Ÿäº¤æ¢ï¼Œåå‘æŸ¥æ‰¾è¡¨ä¹Ÿè¦æ›´æ–°
        self.reverse[self.indexes[1]] = 1
        self.reverse[self.indexes[self.count]] = self.count

        # è®¾ç½®å¤±æ•ˆ
        self.reverse[self.indexes[self.count]] = 0

        self.count -= 1
        self.__shift_down(1)
        return ret

    # æ–°å¢æ–¹æ³•
    def get_min_index(self):
        return self.indexes[1] - 1

    # æ–°å¢æ–¹æ³•
    def get_item(self, i):
        # å†…éƒ¨æ•°ç»„çš„ç´¢å¼•æ¯”ç”¨æˆ·è§†è§’å¤š 1
        return self.data[i + 1]

    # æ–°å¢æ–¹æ³•
    def change(self, i, new_item):
        # æŠŠç”¨æˆ·è§†è§’æ”¹æˆå†…éƒ¨ç´¢å¼•
        i += 1
        self.data[i] = new_item

        # é‡ç‚¹ï¼šä¸‹é¢è¿™ä¸€æ­¥æ˜¯æ‰¾åŸæ¥æ•°ç»„ä¸­ç´¢å¼•æ˜¯ i çš„å…ƒç´ 
        # åœ¨ç´¢å¼•æ•°ç»„ä¸­çš„ç´¢å¼•æ˜¯å‡ ï¼Œè¿™æ˜¯ä¸€ä¸ªå”¯ä¸€å€¼ï¼Œæ‰¾åˆ°å³è¿”å›
        # ä¼˜åŒ–ï¼šå¯ä»¥å¼•å…¥åå‘æŸ¥æ‰¾æŠ€æœ¯ä¼˜åŒ–
        j = self.reverse[i]

        self.__shift_down(j)
        self.__shift_up(j)


# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists: 'List[ListNode]') -> 'ListNode':

        # è¿™ä¸€æ­¥æ˜¯å»æ‰ç©ºé“¾è¡¨
        new_lists = []
        for i in range(len(lists)):
            if lists[i]:
                new_lists.append(lists[i])

        size = len(new_lists)
        index_min_heap = IndexMinHeap(size)
        for i in range(size):
            index_min_heap.insert(i,new_lists[i].val)

        dummy = ListNode(-1)
        cur = dummy
        while index_min_heap.size() > 0:
            index = index_min_heap.get_min_index()

            print(index, index_min_heap.data,new_lists[index].val)
            cur.next = ListNode(new_lists[index].val)
            cur = cur.next
            if new_lists[index].next is None:
                # å¦‚æœåé¢æ²¡æœ‰å…ƒç´ ï¼Œå°±å¯ä»¥åˆ æ‰äº†
                index_min_heap.extract_min_index()
            else:
                index_min_heap.change(index, new_lists[index].next.val)
                new_lists[index] = new_lists[index].next
        return dummy.next


def create_linked_list(nums):
    if len(nums) == 0:
        return None
    head = ListNode(nums[0])
    cur = head
    for i in range(1, len(nums)):
        cur.next = ListNode(nums[i])
        cur = cur.next
    return head


def print_linked_list(list_node):
    if list_node is None:
        return

    cur = list_node
    while cur:
        print(cur.val, '->', end=' ')
        cur = cur.next
    print('null')


if __name__ == '__main__':
    sorted_linked1 = create_linked_list([i for i in range(1, 20, 3)])
    sorted_linked2 = create_linked_list([i for i in range(2, 20, 3)])
    sorted_linked3 = create_linked_list([i for i in range(3, 20, 3)])

    print_linked_list(sorted_linked1)
    print_linked_list(sorted_linked2)
    print_linked_list(sorted_linked3)

    solution = Solution()

    result = solution.mergeKLists(lists=[sorted_linked1, sorted_linked2, sorted_linked3])
    print_linked_list(result)

    sorted_linked1 = create_linked_list([1,2,3])
    sorted_linked2 = create_linked_list([4,5,6,7])
    sorted_linked3 = create_linked_list([])

    solution = Solution()

    result = solution.mergeKLists(lists=[sorted_linked1, sorted_linked2,sorted_linked3])
    print_linked_list(result)
```