## ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€ä¸“é¢˜ 4ï¼šå…¸å‹é—®é¢˜

### ä¾‹é¢˜ï¼šã€ŒåŠ›æ‰£ã€ç¬¬ 347 é¢˜ï¼šå‰Kä¸ªé«˜é¢‘å…ƒç´ 

- é“¾æ¥ï¼š[347. å‰Kä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode-cn.com/problems/top-k-frequent-elements/)ã€‚

> ç»™å®šä¸€ä¸ªéç©ºçš„æ•´æ•°æ•°ç»„ï¼Œè¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ **k** é«˜çš„å…ƒç´ ã€‚
>
> **ç¤ºä¾‹ 1:**
>
> ```
> è¾“å…¥: nums = [1,1,1,2,2,3], k = 2
> è¾“å‡º: [1,2]
> ```
>
> **ç¤ºä¾‹ 2:**
>
> ```
> è¾“å…¥: nums = [1], k = 1
> è¾“å‡º: [1]
> ```
>
> **è¯´æ˜ï¼š**
>
> - ä½ å¯ä»¥å‡è®¾ç»™å®šçš„ *k* æ€»æ˜¯åˆç†çš„ï¼Œä¸” 1 â‰¤ k â‰¤ æ•°ç»„ä¸­ä¸ç›¸åŒçš„å…ƒç´ çš„ä¸ªæ•°ã€‚
> - ä½ çš„ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦**å¿…é¡»**ä¼˜äº O(*n* log *n*) , *n* æ˜¯æ•°ç»„çš„å¤§å°ã€‚

åˆ†æï¼šâ€œ**ä½ çš„ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å¿…é¡»ä¼˜äº** **Oğ‘›ğ‘™ğ‘œğ‘”ğ‘›nlogn , n æ˜¯æ•°ç»„çš„å¤§å°**â€ã€‚è¿™æ˜¯é¢˜ç›®å¯¹æˆ‘ä»¬çš„è¦æ±‚ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°çš„ä¸€ç§æ€è·¯æ˜¯å°† counter ä»¥åçš„æ•°æ®å¯¹ value è¿›è¡Œæ’åºï¼Œä½†å³ä½¿æ˜¯æœ€å¥½çš„æ’åºç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ ğ‘‚(ğ‘›logğ‘›)O(nlogâ¡n)ï¼Œæ¢è¨€ä¹‹ï¼Œé¢˜ç›®é™åˆ¶äº†æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨æ’åºç®—æ³•ã€‚é‚£ä¹ˆï¼Œå¯¹äºå‰ k è¿™æ ·çš„é—®é¢˜ï¼Œä¸€ä¸ªå¾ˆè‡ªç„¶çš„æ€è·¯å°±æ˜¯ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼Œæƒ³åˆ°è¿™ä¸€ç‚¹ï¼Œè¿™é“é—®é¢˜å°±æ˜¯ä¸€ä¸ªå¸¸è§„é—®é¢˜äº†ã€‚

Python ä»£ç ï¼š

python

```python
class Solution:
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        import heapq
        import collections

        # å †æœ‰åºæ•°ç»„
        l = []

        wordcount = collections.defaultdict(int)
        for num in nums:
            wordcount[num] += 1

        for key, val in wordcount.items():
            heapq.heappush(l, (-val, key))
        res = []
        for _ in range(k):
            _, key = heapq.heappop(l)
            res.append(key)
        return res
```

### ã€ŒåŠ›æ‰£ã€ç¬¬ 23 é¢˜ï¼šåˆå¹¶ K ä¸ªæ’åºé“¾è¡¨

ä¼ é€é—¨ï¼š[23. åˆå¹¶Kä¸ªæ’åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/)ã€‚

> åˆå¹¶ *k* ä¸ªæ’åºé“¾è¡¨ï¼Œè¿”å›åˆå¹¶åçš„æ’åºé“¾è¡¨ã€‚è¯·åˆ†æå’Œæè¿°ç®—æ³•çš„å¤æ‚åº¦ã€‚
>
> **ç¤ºä¾‹:**
>
> ```
> è¾“å…¥:
> [
>  1->4->5,
>  1->3->4,
>  2->6
> ]
> è¾“å‡º: 1->1->2->3->4->4->5->6
> ```

### æ–¹æ³•ä¸€ï¼šè´ªå¿ƒç®—æ³•ï¼ˆä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼‰

è¿™æ˜¯ä¸€é“ç±»ä¼¼äºæ•™ç§‘ä¹¦ä¸Šä¾‹é¢˜çš„é—®é¢˜ã€‚è¿™é‡Œæˆ‘ä»¬ä¸¾ç”Ÿæ´»ä¸­çš„ä¾‹å­æ¥ç†è§£æ±‚è§£æ€è·¯ï¼Œå…¶å®ä¸€ç‚¹éƒ½ä¸éš¾ã€‚

å‡è®¾æœ‰å¦‚ä¸‹ç”Ÿæ´»æƒ…å¢ƒï¼šå‡è®¾ä½ æ˜¯ä¸€åä½“è‚²è€å¸ˆï¼Œ**æœ‰** **3** **ä¸ªç­çš„å­¦ç”Ÿï¼Œä»–ä»¬å·²ç»æŒ‰ç…§èº«é«˜ä»çŸ®åˆ°é«˜æ’å¥½æˆäº†** **3** **åˆ—çºµé˜Ÿ**ï¼Œç°åœ¨è¦æŠŠè¿™ 3 ä¸ªç­çš„å­¦ç”Ÿä¹ŸæŒ‰ç…§èº«é«˜ä»çŸ®åˆ°é«˜æ’åˆ—ä¸€åˆ—çºµé˜Ÿã€‚

æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆåšï¼š

1ã€è®© 3 ä¸ªç­çš„å­¦ç”ŸæŒ‰åˆ—ç«™åœ¨ä½ çš„é¢å‰ï¼Œè¿™æ—¶ä½ èƒ½çœ‹åˆ°ç«™åœ¨é˜Ÿé¦–çš„å­¦ç”Ÿçš„å…¨èº«ï¼Œå…¶ä½™åŒå­¦åªèƒ½çœ‹åˆ°æ¯”å‰é¢åŒå­¦è„‘è¢‹é«˜å‡ºçš„é‚£éƒ¨åˆ†ï¼›

2ã€æ¯ä¸€æ¬¡é˜Ÿé¦–çš„ 3 ååŒå­¦ï¼Œè¯·å‡ºæœ€çŸ®çš„åŒå­¦å‡ºåˆ—åˆ°â€œé˜Ÿä¼4â€ï¼ˆå³æˆ‘ä»¬æœ€ç»ˆè®¤ä¸ºæ’å¥½åºçš„é˜Ÿåˆ—ï¼‰ï¼Œå‡ºåˆ—çš„è¿™ä¸€åˆ—çš„åä¸€ååŒå­¦å‘å‰èµ°ä¸€æ­¥ï¼›

3ã€é‡å¤ç¬¬ 2 æ­¥ï¼Œç›´åˆ° 3 ä¸ªç­çš„åŒå­¦å…¨éƒ¨å‡ºåˆ—å®Œæ¯•ã€‚

Python2 ä»£ç ï¼š

æ³¨æ„ï¼šä»¥ä¸‹ä»£ç åœ¨ Python2 ä¸­å¯ä»¥é€šè¿‡ï¼ŒPython3 ä¸­çš„ heapq ä¸æ”¯æŒä¼ å…¥è‡ªå®šä¹‰å¯¹è±¡ï¼Œä¸è¿‡å¯ä»¥ç»•ä¸€ä¸ªå¼¯å­ï¼ŒæŠŠç´¢å¼•å·ä¼ è¿›å»å°±å¯ä»¥äº†

python

```python
class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        import heapq
        l = []
        for head in lists:
            if head:
                heapq.heappush(l, (head.val, head))
        dummy_node = ListNode(-1)
        cur = dummy_node

        while l:
            _, head = heapq.heappop(l)
            cur.next = head
            cur = cur.next
            if head.next:
                heapq.heappush(l, (head.next.val, head.next))

        return dummy_node.next
```

Python3 ä»£ç ï¼š

python

```python
class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        import heapq
        l = []
        size = len(lists)

        for index in range(size):
            if lists[index]:
                heapq.heappush(l, (lists[index].val, index))

        dummy_node = ListNode(-1)
        cur = dummy_node

        while l:
            _, index = heapq.heappop(l)

            head = lists[index]

            cur.next = head
            cur = cur.next
            if head.next:
                heapq.heappush(l, (head.next.val, index))
                lists[index] = head.next
                head.next = None

        return dummy_node.next
```

### æ–¹æ³•äºŒï¼šåˆ†æ²»ç®—æ³•

**è¿˜å¯ä»¥é‡‡ç”¨å½’å¹¶æ’åºçš„åˆ†æ²»æ€æƒ³æ¥è§£å†³ï¼Œä»£ç ç»“æ„å’Œå½’å¹¶æ’åºå¯ä»¥è¯´æ˜¯åŒå‡ºä¸€è¾™ã€‚**

1ã€å…ˆä¸€åˆ†ä¸ºäºŒåœ°è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼›

2ã€å†è€ƒè™‘å¦‚ä½•åˆå¹¶ï¼Œè¿™ä¸ªåˆå¹¶çš„è¿‡ç¨‹ä¹Ÿæ˜¯ä¸€ä¸ªé€’å½’æ–¹æ³•ã€‚

Python ä»£ç ï¼š

python

```python
class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """

        size = len(lists)
        if size == 0:
            return None
        return self.__merge_k_lists(lists, 0, size - 1)

    def __merge_k_lists(self, lists, left, right):
        if left >= right:
            return lists[left]
        mid = left + (right - left) // 2
        listnode1 = self.__merge_k_lists(lists, left, mid)
        listnode2 = self.__merge_k_lists(lists, mid + 1, right)
        return self.__merge_two_sorted_list_node(listnode1, listnode2)

    def __merge_two_sorted_list_node(self, list1, list2):
        if list1 is None:
            return list2
        if list2 is None:
            return list1

        if list1.val < list2.val:
            list1.next = self.__merge_two_sorted_list_node(list1.next, list2)
            return list1
        else:
            list2.next = self.__merge_two_sorted_list_node(list1, list2.next)
            return list2
```

ï¼ˆæœ¬èŠ‚å®Œï¼‰