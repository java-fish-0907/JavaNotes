## ã€ŒåŠ›æ‰£ã€ç¬¬ 126 é¢˜ï¼šå•è¯æ¥é¾™ II

- é“¾æ¥ï¼š[126. å•è¯æ¥é¾™ II](https://leetcode-cn.com/problems/word-ladder-ii/)ï¼›

> ç»™å®šä¸¤ä¸ªå•è¯ï¼ˆ*beginWord* å’Œ *endWord\*ï¼‰å’Œä¸€ä¸ªå­—å…¸ \*wordList\*ï¼Œæ‰¾å‡ºæ‰€æœ‰ä» \*beginWord* åˆ° *endWord* çš„æœ€çŸ­è½¬æ¢åºåˆ—ã€‚è½¬æ¢éœ€éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š
>
> 1. æ¯æ¬¡è½¬æ¢åªèƒ½æ”¹å˜ä¸€ä¸ªå­—æ¯ã€‚
> 2. è½¬æ¢è¿‡ç¨‹ä¸­çš„ä¸­é—´å•è¯å¿…é¡»æ˜¯å­—å…¸ä¸­çš„å•è¯ã€‚
>
> **è¯´æ˜:**
>
> - å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œè¿”å›ä¸€ä¸ªç©ºåˆ—è¡¨ã€‚
> - æ‰€æœ‰å•è¯å…·æœ‰ç›¸åŒçš„é•¿åº¦ã€‚
> - æ‰€æœ‰å•è¯åªç”±å°å†™å­—æ¯ç»„æˆã€‚
> - å­—å…¸ä¸­ä¸å­˜åœ¨é‡å¤çš„å•è¯ã€‚
> - ä½ å¯ä»¥å‡è®¾ *beginWord* å’Œ *endWord* æ˜¯éç©ºçš„ï¼Œä¸”äºŒè€…ä¸ç›¸åŒã€‚
>
> **ç¤ºä¾‹ 1:**
>
> ```
> è¾“å…¥:
> beginWord = "hit",
> endWord = "cog",
> wordList = ["hot","dot","dog","lot","log","cog"]
> 
> è¾“å‡º:
> [
>   ["hit","hot","dot","dog","cog"],
>   ["hit","hot","lot","log","cog"]
> ]
> ```
>
> **ç¤ºä¾‹ 2:**
>
> ```
> è¾“å…¥:
> beginWord = "hit"
> endWord = "cog"
> wordList = ["hot","dot","dog","lot","log"]
> 
> è¾“å‡º: []
> 
> è§£é‡Š: endWord "cog" ä¸åœ¨å­—å…¸ä¸­ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ç¬¦åˆè¦æ±‚çš„è½¬æ¢åºåˆ—ã€‚
> ```

#### è§£é¢˜æ€è·¯ï¼š

è¿™é“é¢˜æ˜¯ä¸€é“å¸¸è§çš„è€ƒé¢˜ï¼Œæ²¡æœ‰ç‰¹åˆ«éš¾ç†è§£çš„æŠ€å·§ï¼Œå®Œå…¨å¯ä»¥ç”±å·²æœ‰çš„çŸ¥è¯†è¿ç§»è¿‡æ¥ã€‚**ä¸»è¦è€ƒå¯Ÿçš„æ˜¯ç¼–ç å’Œè€å¿ƒè°ƒè¯•çš„èƒ½åŠ›**ã€‚ä»¥ä¸‹ä»£ç é‡è¾ƒå¤šï¼Œä»…ä¾›å‚è€ƒï¼Œå»ºè®®è¯»è€…ç†è§£æ¸…æ¥šè§£é¢˜æ€æƒ³ä»¥åï¼Œè‡ªè¡Œç¼–ç ã€è°ƒè¯•å®Œæˆã€‚

æ€è·¯åˆ†æï¼š

- å•è¯åˆ—è¡¨ã€èµ·ç‚¹ã€ç»ˆç‚¹æ„æˆ

  æ— å‘å›¾

  ï¼Œå®¹æ˜“æƒ³åˆ°ä½¿ç”¨

  å¹¿åº¦ä¼˜å…ˆéå†

  æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼šå›¾ä¸­å¹¿åº¦ä¼˜å…ˆéå†è¦ä½¿ç”¨åˆ°ï¼›

  - é˜Ÿåˆ—ï¼›
  - æ ‡è®°æ˜¯å¦è®¿é—®è¿‡çš„ã€Œå¸ƒå°”æ•°ç»„ã€æˆ–è€…ã€Œå“ˆå¸Œè¡¨ã€`visited`ï¼Œè¿™é‡Œ key æ˜¯å­—ç¬¦ä¸²ï¼Œæ•…ä½¿ç”¨å“ˆå¸Œè¡¨ï¼›

è¯´æ˜ï¼šæœ¬é¢˜å¯ä»¥åœ¨ `wordList` ï¼ˆæ·»åŠ åˆ°å“ˆå¸Œè¡¨ä»¥åï¼‰ä¸Šåšå‡æ³•ï¼Œä¸è¿‡æ ‡å‡†çš„ã€æ›´å¯é çš„åšæ³•æ˜¯ï¼Œå¦å¤–ä½¿ç”¨ä¸€ä¸ª `visited` å“ˆå¸Œè¡¨ï¼Œå°†è®¿é—®ä»¥åçš„å•è¯æ·»åŠ åˆ° `visited` å“ˆå¸Œè¡¨ä¸­ï¼Œä¸‹é¢ç»™å‡ºçš„å‚è€ƒä»£ç éƒ½é‡‡ç”¨è¿™ç§ä¸èŠ‚çº¦ç©ºé—´çš„åšæ³•ã€‚

- é‡ç‚¹ï¼šç”±äºè¦è®°å½•**æ‰€æœ‰çš„**è·¯å¾„ï¼Œå¹¿åº¦ä¼˜å…ˆéå†ã€Œå½“å‰å±‚ã€åˆ°ã€Œä¸‹ä¸€å±‚ã€çš„æ‰€æœ‰è·¯å¾„éƒ½å¾—è®°å½•ä¸‹æ¥ã€‚å› æ­¤æ‰¾åˆ°ä¸‹ä¸€å±‚çš„ç»“ç‚¹ `wordA` ä»¥åï¼Œ**ä¸èƒ½é©¬ä¸Šæ·»åŠ åˆ° `visited` å“ˆå¸Œè¡¨é‡Œï¼Œè¿˜éœ€è¦æ£€æŸ¥å½“å‰é˜Ÿåˆ—ä¸­æœªå‡ºé˜Ÿçš„å•è¯æ˜¯å¦è¿˜èƒ½ä¸ `wordA` å»ºç«‹è”ç³»**ï¼›
- å¹¿åº¦ä¼˜å…ˆéå†ä½äºåŒä¸€å±‚çš„å•è¯ï¼Œå³ä½¿æœ‰è”ç³»ï¼Œä¹Ÿæ˜¯ä¸å¯ä»¥è¢«è®°å½•ä¸‹æ¥çš„ï¼Œè¿™æ˜¯å› ä¸º**åŒä¸€å±‚çš„è¿æ¥è‚¯å®šä¸æ˜¯èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„çš„è¾¹**ï¼›
- ä½¿ç”¨ BFS çš„åŒæ—¶è®°å½•éå†çš„è·¯å¾„ï¼Œå½¢å¼ï¼šå“ˆå¸Œè¡¨ã€‚å“ˆå¸Œè¡¨çš„ key è®°å½•äº†ã€Œé¡¶ç‚¹å­—ç¬¦ä¸²ã€ï¼Œå“ˆå¸Œè¡¨çš„å€¼ value è®°å½•äº† key å¯¹åº”çš„å­—ç¬¦ä¸²åœ¨å¹¿åº¦ä¼˜å…ˆéå†çš„è¿‡ç¨‹ä¸­å¾—åˆ°çš„æ‰€æœ‰åç»§ç»“ç‚¹åˆ—è¡¨ `successors`ï¼›
- æœ€åæ ¹æ® `successors`ï¼Œä½¿ç”¨**å›æº¯ç®—æ³•**ï¼ˆå…¨ç¨‹ä½¿ç”¨ä¸€ä»½è·¯å¾„å˜é‡æœç´¢æ‰€æœ‰å¯èƒ½ç»“æœçš„æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•ï¼‰å¾—åˆ°æ‰€æœ‰çš„æœ€çŸ­è·¯å¾„ã€‚

------

#### æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆéå†

- å¦‚æœå¼€å§‹å°±æ„å»ºå›¾ï¼Œç»“æœå¯èƒ½ä¼šè¶…æ—¶ï¼Œè¿™é‡Œé‡‡ç”¨çš„æ–¹æ³•æ˜¯ï¼šå…ˆæŠŠ `wordList` å­˜å…¥å“ˆå¸Œè¡¨ï¼Œç„¶åæ˜¯ä¸€è¾¹éå†ï¼Œä¸€è¾¹æ‰¾é‚»å±…ï¼Œè¿›è€Œæ„å»ºå›¾ï¼Œè¿™æ˜¯è§£å†³è¿™ä¸ªé—®é¢˜çš„ç‰¹ç‚¹ï¼›
- æ¯ä¸€å±‚ä½¿ç”¨ä¸€ä¸ªæ–°çš„ `nextLevelVisited` å“ˆå¸Œè¡¨ï¼Œè®°å½•å½“å‰å±‚çš„ä¸‹ä¸€å±‚å¯ä»¥è®¿é—®åˆ°å“ªäº›ç»“ç‚¹ã€‚**ç›´åˆ°ä¸Šä¸€å±‚é˜Ÿåˆ—é‡Œçš„å€¼éƒ½å‡ºé˜Ÿä»¥åï¼Œ `nextLevelVisited` å“ˆå¸Œè¡¨æ‰æ·»åŠ åˆ°æ€»çš„ `visited` å“ˆå¸Œè¡¨ï¼Œè¿™æ ·è®°å½•å½“å‰ç»“ç‚¹å’Œå¹¿åº¦ä¼˜å…ˆéå†åˆ°çš„å­ç»“ç‚¹åˆ—è¡¨æ‰ä¸ä¼šé—æ¼**ã€‚



![image.png](https://pic.leetcode-cn.com/da957ec0ab9fe9eda166acab86ba9fca8b6b0f6b04bda3e35677a46fb53d7d17-image.png)

**image.png**



ä¸ºæ­¤ï¼Œè®¾è®¡ç®—æ³•æµç¨‹å¦‚ä¸‹ï¼š

- ç¬¬ 1 æ­¥ï¼šä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†æ‰¾åˆ°ç»ˆç‚¹å•è¯ï¼Œå¹¶ä¸”è®°å½•ä¸‹æ²¿é€”ç»è¿‡çš„æ‰€æœ‰ç»“ç‚¹ï¼Œä»¥é‚»æ¥è¡¨å½¢å¼å­˜å‚¨ï¼›
- ç¬¬ 2 æ­¥ï¼šé€šè¿‡é‚»æ¥è¡¨ï¼Œä½¿ç”¨å›æº¯ç®—æ³•å¾—åˆ°æ‰€æœ‰ä»èµ·ç‚¹å•è¯åˆ°ç»ˆç‚¹å•è¯çš„è·¯å¾„ã€‚

**å‚è€ƒä»£ç  1**ï¼š

Java ä»£ç ï¼š

```java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;


public class Solution {

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        // å…ˆå°† wordList æ”¾åˆ°å“ˆå¸Œè¡¨é‡Œï¼Œä¾¿äºåˆ¤æ–­æŸä¸ªå•è¯æ˜¯å¦åœ¨ wordList é‡Œ
        Set<String> wordSet = new HashSet<>(wordList);
        List<List<String>> res = new ArrayList<>();
        if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
            return res;
        }

        // ç¬¬ 1 æ­¥ï¼šä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†å¾—åˆ°åç»§ç»“ç‚¹åˆ—è¡¨ successors
        // keyï¼šå­—ç¬¦ä¸²ï¼Œvalueï¼šå¹¿åº¦ä¼˜å…ˆéå†è¿‡ç¨‹ä¸­ key çš„åç»§ç»“ç‚¹åˆ—è¡¨
        Map<String, Set<String>> successors = new HashMap<>();
        boolean found = bfs(beginWord, endWord, wordSet, successors);
        if (!found) {
            return res;
        }

        // ç¬¬ 2 æ­¥ï¼šåŸºäºåç»§ç»“ç‚¹åˆ—è¡¨ successors ï¼Œä½¿ç”¨å›æº¯ç®—æ³•å¾—åˆ°æ‰€æœ‰æœ€çŸ­è·¯å¾„åˆ—è¡¨
        Deque<String> path = new ArrayDeque<>();
        path.addLast(beginWord);
        dfs(beginWord, endWord, successors, path, res);
        return res;
    }

    private boolean bfs(String beginWord, String endWord, Set<String> wordSet,
                        Map<String, Set<String>> successors) {
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);

        // è®°å½•è®¿é—®è¿‡çš„å•è¯
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);

        boolean found = false;
        int wordLen = beginWord.length();
        // å½“å‰å±‚è®¿é—®è¿‡çš„ç»“ç‚¹ï¼Œå½“å‰å±‚å…¨éƒ¨éå†å®Œæˆä»¥åï¼Œå†æ·»åŠ åˆ°æ€»çš„ visited é›†åˆé‡Œ
        Set<String> nextLevelVisited = new HashSet<>();
        while (!queue.isEmpty()) {
            int currentSize = queue.size();
            for (int i = 0; i < currentSize; i++) {
                String currentWord = queue.poll();
                char[] charArray = currentWord.toCharArray();
                for (int j = 0; j < wordLen; j++) {
                    char originChar = charArray[j];
                    for (char k = 'a'; k <= 'z'; k++) {
                        if (charArray[j] == k) {
                            continue;
                        }
                        charArray[j] = k;
                        String nextWord = new String(charArray);
                        if (wordSet.contains(nextWord)) {
                            if (!visited.contains(nextWord)) {
                                if (nextWord.equals(endWord)) {
                                    found = true;
                                }
                                nextLevelVisited.add(nextWord);
                                queue.offer(nextWord);

                                // ç»´æŠ¤ successors çš„å®šä¹‰
                                successors.computeIfAbsent(currentWord, a -> new HashSet<>());
                                successors.get(currentWord).add(nextWord);
                            }
                        }
                    }
                    charArray[j] = originChar;
                }
            }

            if (found) {
                break;
            }
            visited.addAll(nextLevelVisited);
            nextLevelVisited.clear();
        }
        return found;
    }

    private void dfs(String beginWord, String endWord,
                     Map<String, Set<String>> successors,
                     Deque<String> path, List<List<String>> res) {
        if (beginWord.equals(endWord)) {
            res.add(new ArrayList<>(path));
            return;
        }

        if (!successors.containsKey(beginWord)) {
            return;
        }

        Set<String> successorWords = successors.get(beginWord);
        for (String nextWord : successorWords) {
            path.addLast(nextWord);
            dfs(nextWord, endWord, successors, path, res);
            path.removeLast();
        }
    }

    public static void main(String[] args) {
        String[] words = {"rex", "ted", "tex", "tad", "tax"};
        List<String> wordList = new ArrayList<>();
        Collections.addAll(wordList, words);

        Solution solution = new Solution();
        String beginWord = "red";
        String endWord = "tax";
        List<List<String>> res = solution.findLadders(beginWord, endWord, wordList);
        System.out.println(res);
    }
}
```

Python ä»£ç ï¼š

```python
from collections import defaultdict
from typing import List
from collections import deque
import string


class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        # å…ˆå°† wordList æ”¾åˆ°å“ˆå¸Œè¡¨é‡Œï¼Œä¾¿äºåˆ¤æ–­æŸä¸ªå•è¯æ˜¯å¦åœ¨ wordList é‡Œ
        word_set = set(wordList)
        res = []
        if len(word_set) == 0 or endWord not in word_set:
            return res

        successors = defaultdict(set)
        # ç¬¬ 1 æ­¥ï¼šä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†å¾—åˆ°åç»§ç»“ç‚¹åˆ—è¡¨ successors
        # keyï¼šå­—ç¬¦ä¸²ï¼Œvalueï¼šå¹¿åº¦ä¼˜å…ˆéå†è¿‡ç¨‹ä¸­ key çš„åç»§ç»“ç‚¹åˆ—è¡¨
        found = self.__bfs(beginWord, endWord, word_set, successors)
        if not found:
            return res
        # ç¬¬ 2 æ­¥ï¼šåŸºäºåç»§ç»“ç‚¹åˆ—è¡¨ successors ï¼Œä½¿ç”¨å›æº¯ç®—æ³•å¾—åˆ°æ‰€æœ‰æœ€çŸ­è·¯å¾„åˆ—è¡¨
        path = [beginWord]
        self.__dfs(beginWord, endWord, successors, path, res)
        return res

    def __bfs(self, beginWord, endWord, word_set, successors):
        queue = deque()
        queue.append(beginWord)

        visited = set()
        visited.add(beginWord)

        found = False
        word_len = len(beginWord)
        next_level_visited = set()

        while queue:
            current_size = len(queue)
            for i in range(current_size):
                current_word = queue.popleft()
                word_list = list(current_word)

                for j in range(word_len):
                    origin_char = word_list[j]

                    for k in string.ascii_lowercase:
                        word_list[j] = k
                        next_word = ''.join(word_list)

                        if next_word in word_set:
                            if next_word not in visited:
                                if next_word == endWord:
                                    found = True
                                next_level_visited.add(next_word)
                                queue.append(next_word)

                                successors[current_word].add(next_word)
                    word_list[j] = origin_char
            if found:
                break
            # å–ä¸¤é›†åˆå…¨éƒ¨çš„å…ƒç´ ï¼ˆå¹¶é›†ï¼Œç­‰ä»·äºå°† next_level_visited é‡Œçš„æ‰€æœ‰å…ƒç´ æ·»åŠ åˆ° visited é‡Œï¼‰
            visited |= next_level_visited
            next_level_visited.clear()
        return found

    def __dfs(self, beginWord, endWord, successors, path, res):
        if beginWord == endWord:
            res.append(path[:])
            return

        if beginWord not in successors:
            return

        successor_words = successors[beginWord]
        for next_word in successor_words:
            path.append(next_word)
            self.__dfs(next_word, endWord, successors, path, res)
            path.pop()


if __name__ == '__main__':
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot", "dot", "dog", "lot", "log", "cog"]

    solution = Solution()
    res = solution.findLadders(beginWord, endWord, wordList)
    print(res)
```

**å¤æ‚åº¦åˆ†æ**ï¼šï¼ˆå¦‚æœ‰é”™è¯¯è¿˜è¯·æœ‹å‹ä»¬è¯·æŒ‡æ­£ï¼‰

- æ—¶é—´å¤æ‚åº¦ï¼š

  

  ğ‘‚(ğ‘Ã—26Ã—ğ‘¤ğ‘œğ‘Ÿğ‘‘ğ¿ğ‘’ğ‘›+ğ‘2ğ‘)O(NÃ—26Ã—wordLen+N2N)

  - å¹¿åº¦ä¼˜å…ˆéå†ï¼šæœ€å·®æƒ…å†µä¸‹æ¯ä¸ªç»“ç‚¹éå†ä¸€æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(ğ‘)O(N)ï¼Œè¿™é‡Œ ğ‘N æ˜¯å•è¯åˆ—è¡¨çš„å•è¯æ€»æ•°ï¼›
  - å»ºå›¾ï¼šä¸€å¼€å§‹å°†æ‰€æœ‰å•è¯æ”¾è¿›å“ˆå¸Œè¡¨ ğ‘‚(ğ‘)O(N)ï¼Œæ¯ä¸€ä¸ªå•è¯æŸ¥æ‰¾é‚»å±… ğ‘‚(26Ã—ğ‘¤ğ‘œğ‘Ÿğ‘‘ğ¿ğ‘’ğ‘›)O(26Ã—wordLen)ï¼Œ`wordLen` è¡¨ç¤ºå•è¯çš„é•¿åº¦ï¼Œä¸€èˆ¬è€Œè¨€ä¸ä¼šå¾ˆå¤§ï¼Œæ¯”èµ· ğ‘N ä¼šå°å¾ˆå¤šï¼Œç”šè‡³å¯ä»¥è§†ä¸ºå¸¸æ•°ï¼›
  - å›æº¯ç®—æ³•ï¼šæŒ‡æ•°çº§åˆ« ğ‘‚(2ğ‘)O(2N)ï¼Œè®°å½•æ¯ä¸€ä¸ªç»“æœ ğ‘‚(ğ‘)O(N)ï¼Œè¿™é‡Œè®¤ä¸ºæœ€åæƒ…å†µä¸‹ï¼Œæœ€çŸ­è·¯å¾„ä¸ºå•è¯åˆ—è¡¨çš„å•è¯æ€»æ•°ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼šğ‘‚(ğ‘¤ğ‘ğ‘¦ğ‘ Ã—ğ‘Ã—ğ‘¤ğ‘œğ‘Ÿğ‘‘ğ¿ğ‘’ğ‘›)O(waysÃ—NÃ—wordLen)ï¼Œè¿™é‡Œ ways è¡¨ç¤ºæœ€çŸ­è·¯å¾„çš„æ–¹æ¡ˆæ•°ã€‚

è¯´æ˜ï¼š





java

```java
successors.computeIfAbsent(currentWord, a -> new HashSet<>());
successors.get(currentWord).add(nextWord);
```

ä»¥ä¸Šä»£ç ä» Java 1.8 ä»¥åæ”¯æŒï¼Œç­‰ä»·çš„ä»£ç ç‰‡æ®µæ˜¯ï¼š

```java
// ç»´æŠ¤ successors çš„å®šä¹‰
if (successors.containsKey(currentWord)) {
    successors.get(currentWord).add(nextWord);
} else {
    Set<String> newSet = new HashSet<>();
    newSet.add(nextWord);
    successors.put(currentWord, newSet);
}
```

------

#### æ–¹æ³•äºŒï¼šåŒå‘å¹¿åº¦ä¼˜å…ˆéå†

- ç”±äºæˆ‘ä»¬è¿™ä¸ªé—®é¢˜çŸ¥é“ç›®æ ‡å€¼ï¼Œå› æ­¤å¯ä»¥è®©èµ·ç‚¹å’Œç»ˆç‚¹ã€ŒåŒæ—¶ã€åš BFSï¼Œç›´åˆ°å®ƒä»¬åˆäº¤é›†ï¼Œä¸¤è¾¹ä¸€èµ·æ‰©æ•£å½¢æˆçš„è·¯å¾„ä¹Ÿæ˜¯æœ€çŸ­è·¯å¾„ï¼›
- åŒå‘ BFS æœ‰ç‚¹åƒå±±æ´æŒ–éš§é“ï¼Œä¸¤è¾¹ä¸€èµ·æŒ–ï¼Œç›´åˆ°æ‰“é€šä¸ºæ­¢ã€‚åŒå‘ BFS æœç´¢åˆ°çš„é›†åˆæ›´å°ï¼Œç›¸å½“äºåšäº†ä¸€äº›å‰ªææ“ä½œï¼Œå› æ­¤ä¼šæ›´å¿«ä¸€äº›ã€‚



![image.png](https://pic.leetcode-cn.com/cd190a4a61445ac9affc344f941da381d64a163b81c7594f342d45793c5bfd06-image.png)

**image.png**



ç¼–ç è¯´æ˜ï¼š

- å‚è€ƒä»£ç  2 ä¸å‚è€ƒä»£ç  1 ä»…ä»…æŠŠã€Œå¹¿åº¦ä¼˜å…ˆéå†ã€æ–¹æ³•çš„å®ç°æ”¹æˆäº†ã€ŒåŒå‘å¹¿åº¦ä¼˜å…ˆéå†ã€ï¼Œå›æº¯çš„ä»£ç æ˜¯ä¸€æ ·çš„ï¼›
- `beginVisited` å’Œ `endVisited` äº¤æ›¿ä½¿ç”¨ï¼Œå®ç°ç±»ä¼¼é˜Ÿåˆ—ï¼ˆç¬¦åˆé¡ºåºæ€§ï¼Œå…ˆè¿›å…ˆå‡ºï¼‰çš„æ•ˆæœï¼›
- æ³¨æ„ï¼šä¸ä¸€å®šéè¦ä¸¥æ ¼æŒ‰ç…§ã€Œä¸€å·¦ä¸€å³ã€çš„é¡ºåºäº¤æ›¿å‘ä¸­é—´æ‰©æ•£ï¼Œ**æ¯æ¬¡éƒ½ä»è¾ƒå°çš„é›†åˆæ‰©æ•£ï¼Œç»Ÿè®¡æ„ä¹‰ä¸Šæœç´¢çš„èŒƒå›´æ›´å°**ï¼›
- ç†è§£ä¸‹é¢è®¾è®¡ `forward` å˜é‡çš„ä½œç”¨ï¼Œè™½ç„¶æ˜¯åŒå‘æ‰©æ•£ï¼Œä½†æ˜¯è®°å½•ã€Œåç»§ç»“ç‚¹åˆ—è¡¨ã€çš„æ—¶å€™æ–¹å‘å›ºå®šã€‚

**å‚è€ƒä»£ç  2**ï¼š

Java ä»£ç ï¼š

```java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Solution {

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        // å…ˆå°† wordList æ”¾åˆ°å“ˆå¸Œè¡¨é‡Œï¼Œä¾¿äºåˆ¤æ–­æŸä¸ªå•è¯æ˜¯å¦åœ¨ wordList é‡Œ
        List<List<String>> res = new ArrayList<>();
        Set<String> wordSet = new HashSet<>(wordList);
        if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
            return res;
        }
        // ç¬¬ 1 æ­¥ï¼šä½¿ç”¨åŒå‘å¹¿åº¦ä¼˜å…ˆéå†å¾—åˆ°åç»§ç»“ç‚¹åˆ—è¡¨ successors
        // keyï¼šå­—ç¬¦ä¸²ï¼Œvalueï¼šå¹¿åº¦ä¼˜å…ˆéå†è¿‡ç¨‹ä¸­ key çš„åç»§ç»“ç‚¹åˆ—è¡¨
        Map<String, Set<String>> successors = new HashMap<>();
        boolean found = bidirectionalBfs(beginWord, endWord, wordSet, successors);
        if (!found) {
            return res;
        }
        // ç¬¬ 2 æ­¥ï¼šåŸºäºåç»§ç»“ç‚¹åˆ—è¡¨ successors ï¼Œä½¿ç”¨å›æº¯ç®—æ³•å¾—åˆ°æ‰€æœ‰æœ€çŸ­è·¯å¾„åˆ—è¡¨
        Deque<String> path = new ArrayDeque<>();
        path.addLast(beginWord);
        dfs(beginWord, endWord, successors, path, res);
        return res;
    }

    private boolean bidirectionalBfs(String beginWord,
                                     String endWord,
                                     Set<String> wordSet,
                                     Map<String, Set<String>> successors) {
        // è®°å½•è®¿é—®è¿‡çš„å•è¯
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);
        visited.add(endWord);

        Set<String> beginVisited = new HashSet<>();
        beginVisited.add(beginWord);
        Set<String> endVisited = new HashSet<>();
        endVisited.add(endWord);

        int wordLen = beginWord.length();
        boolean forward = true;
        boolean found = false;
        // åœ¨ä¿è¯äº† beginVisited æ€»æ˜¯è¾ƒå°ï¼ˆå¯ä»¥ç­‰äºï¼‰å¤§å°çš„é›†åˆå‰æä¸‹ï¼Œ&& !endVisited.isEmpty() å¯ä»¥çœç•¥
        while (!beginVisited.isEmpty() && !endVisited.isEmpty()) {
            // ä¸€ç›´ä¿è¯ beginVisited æ˜¯ç›¸å¯¹è¾ƒå°çš„é›†åˆï¼Œæ–¹ä¾¿åç»­ç¼–ç 
            if (beginVisited.size() > endVisited.size()) {
                Set<String> temp = beginVisited;
                beginVisited = endVisited;
                endVisited = temp;

                // åªè¦äº¤æ¢ï¼Œå°±æ›´æ”¹æ–¹å‘ï¼Œä»¥ä¾¿ç»´æŠ¤ successors çš„å®šä¹‰
                forward = !forward;
            }
            Set<String> nextLevelVisited = new HashSet<>();
            // é»˜è®¤ beginVisited æ˜¯å°é›†åˆï¼Œå› æ­¤ä» beginVisited å‡ºå‘
            for (String currentWord : beginVisited) {
                char[] charArray = currentWord.toCharArray();
                for (int i = 0; i < wordLen; i++) {
                    char originChar = charArray[i];
                    for (char j = 'a'; j <= 'z'; j++) {
                        if (charArray[i] == j) {
                            continue;
                        }
                        charArray[i] = j;
                        String nextWord = new String(charArray);
                        if (wordSet.contains(nextWord)) {
                            if (endVisited.contains(nextWord)) {
                                found = true;
                                // åœ¨å¦ä¸€ä¾§æ‰¾åˆ°å•è¯ä»¥åï¼Œè¿˜éœ€æŠŠè¿™ä¸€å±‚å…³ç³»æ·»åŠ åˆ°ã€Œåç»§ç»“ç‚¹åˆ—è¡¨ã€
                                addToSuccessors(successors, forward, currentWord, nextWord);
                            }

                            if (!visited.contains(nextWord)) {
                                nextLevelVisited.add(nextWord);
                                addToSuccessors(successors, forward, currentWord, nextWord);
                            }
                        }
                    }
                    charArray[i] = originChar;
                }
            }
            beginVisited = nextLevelVisited;
            visited.addAll(nextLevelVisited);
            if (found) {
                break;
            }
        }
        return found;
    }

    private void dfs(String beginWord,
                     String endWord,
                     Map<String, Set<String>> successors,
                     Deque<String> path,
                     List<List<String>> res) {

        if (beginWord.equals(endWord)) {
            res.add(new ArrayList<>(path));
            return;
        }

        if (!successors.containsKey(beginWord)) {
            return;
        }

        Set<String> successorWords = successors.get(beginWord);
        for (String successor : successorWords) {
            path.addLast(successor);
            dfs(successor, endWord, successors, path, res);
            path.removeLast();
        }
    }

    private void addToSuccessors(Map<String, Set<String>> successors, boolean forward,
                                 String currentWord, String nextWord) {
        if (!forward) {
            String temp = currentWord;
            currentWord = nextWord;
            nextWord = temp;
        }

        // Java 1.8 ä»¥åæ”¯æŒ
        successors.computeIfAbsent(currentWord, a -> new HashSet<>());
        successors.get(currentWord).add(nextWord);
    }


    public static void main(String[] args) {
        List<String> wordList = new ArrayList<>();
        wordList.add("hot");
        wordList.add("dot");
        wordList.add("dog");
        wordList.add("lot");
        wordList.add("log");
        wordList.add("cog");


        Solution solution = new Solution();
        String beginWord = "hit";
        String endWord = "cog";
        List<List<String>> res = solution.findLadders(beginWord, endWord, wordList);
        System.out.println(res);
    }
}
```

Python ä»£ç ï¼š

```python
from collections import defaultdict
from typing import List
from collections import deque
import string


class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        # å…ˆå°† wordList æ”¾åˆ°å“ˆå¸Œè¡¨é‡Œï¼Œä¾¿äºåˆ¤æ–­æŸä¸ªå•è¯æ˜¯å¦åœ¨ wordList é‡Œ
        word_set = set(wordList)
        res = []
        if len(word_set) == 0 or endWord not in word_set:
            return res

        successors = defaultdict(set)
        # ç¬¬ 1 æ­¥ï¼šä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†å¾—åˆ°åç»§ç»“ç‚¹åˆ—è¡¨ successors
        # keyï¼šå­—ç¬¦ä¸²ï¼Œvalueï¼šå¹¿åº¦ä¼˜å…ˆéå†è¿‡ç¨‹ä¸­ key çš„åç»§ç»“ç‚¹åˆ—è¡¨
        found = self.__bidirectional_bfs(beginWord, endWord, word_set, successors)
        if not found:
            return res
        # ç¬¬ 2 æ­¥ï¼šåŸºäºåç»§ç»“ç‚¹åˆ—è¡¨ successors ï¼Œä½¿ç”¨å›æº¯ç®—æ³•å¾—åˆ°æ‰€æœ‰æœ€çŸ­è·¯å¾„åˆ—è¡¨
        path = [beginWord]
        self.__dfs(beginWord, endWord, successors, path, res)
        return res

    def __bidirectional_bfs(self, beginWord, endWord, word_set, successors):
        visited = set()
        visited.add(beginWord)
        visited.add(endWord)

        begin_visited = set()
        begin_visited.add(beginWord)

        end_visited = set()
        end_visited.add(endWord)

        found = False
        forward = True
        word_len = len(beginWord)
        while begin_visited:
            if len(begin_visited) > len(end_visited):
                begin_visited, end_visited = end_visited, begin_visited
                forward = not forward

            next_level_visited = set()
            for current_word in begin_visited:
                word_list = list(current_word)
                for j in range(word_len):
                    origin_char = word_list[j]
                    for k in string.ascii_lowercase:
                        word_list[j] = k
                        next_word = ''.join(word_list)
                        if next_word in word_set:
                            if next_word in end_visited:
                                found = True
                                # åœ¨å¦ä¸€ä¾§æ‰¾åˆ°å•è¯ä»¥åï¼Œè¿˜éœ€æŠŠè¿™ä¸€å±‚å…³ç³»æ·»åŠ åˆ°ã€Œåç»§ç»“ç‚¹åˆ—è¡¨ã€
                                self.__add_to_successors(successors, forward, current_word, next_word)
                            if next_word not in visited:
                                next_level_visited.add(next_word)
                                self.__add_to_successors(successors, forward, current_word, next_word)
                    word_list[j] = origin_char
            begin_visited = next_level_visited
            # å–ä¸¤é›†åˆå…¨éƒ¨çš„å…ƒç´ ï¼ˆå¹¶é›†ï¼Œç­‰ä»·äºå°† next_level_visited é‡Œçš„æ‰€æœ‰å…ƒç´ æ·»åŠ åˆ° visited é‡Œï¼‰
            visited |= next_level_visited
            if found:
                break
        return found

    def __add_to_successors(self, successors, forward, current_word, next_word):
        if forward:
            successors[current_word].add(next_word)
        else:
            successors[next_word].add(current_word)

    def __dfs(self, beginWord, endWord, successors, path, res):
        if beginWord == endWord:
            res.append(path[:])
            return

        if beginWord not in successors:
            return

        successor_words = successors[beginWord]
        for next_word in successor_words:
            path.append(next_word)
            self.__dfs(next_word, endWord, successors, path, res)
            path.pop()


if __name__ == '__main__':
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot", "dot", "dog", "lot", "log", "cog"]

    solution = Solution()
    res = solution.findLadders(beginWord, endWord, wordList)
    print(res)
```