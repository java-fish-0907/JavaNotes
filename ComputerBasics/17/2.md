## ã€ŒåŠ›æ‰£ã€ç¬¬ 127 é¢˜ï¼šå•è¯æ¥é¾™

- é¢˜ç›®é“¾æ¥ï¼š[127. å•è¯æ¥é¾™](https://leetcode-cn.com/problems/word-ladder/)
- é¢˜è§£é“¾æ¥ï¼š[å¹¿åº¦ä¼˜å…ˆéå†ã€åŒå‘å¹¿åº¦ä¼˜å…ˆéå†ï¼ˆJavaã€Pythonï¼‰](https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/)

> ç»™å®šä¸¤ä¸ªå•è¯ï¼ˆ `beginWord` å’Œ `endWord`ï¼‰å’Œä¸€ä¸ªå­—å…¸ï¼Œæ‰¾åˆ°ä» `beginWord` åˆ° `endWord` çš„æœ€çŸ­è½¬æ¢åºåˆ—çš„é•¿åº¦ã€‚è½¬æ¢éœ€éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š
>
> 1. æ¯æ¬¡è½¬æ¢åªèƒ½æ”¹å˜ä¸€ä¸ªå­—æ¯ã€‚
> 2. è½¬æ¢è¿‡ç¨‹ä¸­çš„ä¸­é—´å•è¯å¿…é¡»æ˜¯å­—å…¸ä¸­çš„å•è¯ã€‚
>
> **è¯´æ˜:**
>
> - å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œè¿”å› 0ã€‚
> - æ‰€æœ‰å•è¯å…·æœ‰ç›¸åŒçš„é•¿åº¦ã€‚
> - æ‰€æœ‰å•è¯åªç”±å°å†™å­—æ¯ç»„æˆã€‚
> - å­—å…¸ä¸­ä¸å­˜åœ¨é‡å¤çš„å•è¯ã€‚
> - ä½ å¯ä»¥å‡è®¾ `beginWord` å’Œ `endWord` æ˜¯éç©ºçš„ï¼Œä¸”äºŒè€…ä¸ç›¸åŒã€‚
>
> **ç¤ºä¾‹ 1:**
>
> ```
> è¾“å…¥:
> beginWord = "hit",
> endWord = "cog",
> wordList = ["hot","dot","dog","lot","log","cog"]
> 
> è¾“å‡º: 5
> 
> è§£é‡Š: ä¸€ä¸ªæœ€çŸ­è½¬æ¢åºåˆ—æ˜¯ "hit" -> "hot" -> "dot" -> "dog" -> "cog",
>      è¿”å›å®ƒçš„é•¿åº¦ 5ã€‚
> ```
>
> **ç¤ºä¾‹ 2:**
>
> ```
> è¾“å…¥:
> beginWord = "hit"
> endWord = "cog"
> wordList = ["hot","dot","dog","lot","log"]
> 
> è¾“å‡º: 0
> 
> è§£é‡Š: endWord "cog" ä¸åœ¨å­—å…¸ä¸­ï¼Œæ‰€ä»¥æ— æ³•è¿›è¡Œè½¬æ¢ã€‚
> ```

### ä¸€å¥è¯é¢˜è§£

> æ— å‘å›¾ä¸­ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ï¼Œå¯ä»¥é€šè¿‡å¹¿åº¦ä¼˜å…ˆéå†å¾—åˆ°ï¼›
>
> ä¸ºä»€ä¹ˆ BFS å¾—åˆ°çš„è·¯å¾„æœ€çŸ­ï¼Ÿå¯ä»¥æŠŠèµ·ç‚¹å’Œç»ˆç‚¹æ‰€åœ¨çš„è·¯å¾„æ‹‰ç›´æ¥çœ‹ï¼Œä¸¤ç‚¹ä¹‹é—´çº¿æ®µæœ€çŸ­ï¼›
>
> å·²çŸ¥ç›®æ ‡é¡¶ç‚¹çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥åˆ†åˆ«ä»èµ·ç‚¹å’Œç›®æ ‡é¡¶ç‚¹ï¼ˆç»ˆç‚¹ï¼‰æ‰§è¡Œå¹¿åº¦ä¼˜å…ˆéå†ï¼Œç›´åˆ°éå†çš„éƒ¨åˆ†æœ‰äº¤é›†ï¼Œè¿™æ˜¯åŒå‘å¹¿åº¦ä¼˜å…ˆéå†çš„æ€æƒ³ã€‚

### æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆéå†

åˆ†æé¢˜æ„ï¼š

- ã€Œè½¬æ¢ã€æ„å³ï¼šä¸¤ä¸ªå•è¯å¯¹åº”ä½ç½®åªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸åŒï¼Œä¾‹å¦‚ â€œhitâ€ ä¸ â€œhotâ€ï¼Œè¿™ç§è½¬æ¢æ˜¯å¯ä»¥é€†å‘çš„ï¼Œå› æ­¤ï¼Œæ ¹æ®é¢˜ç›®ç»™å‡ºçš„å•è¯åˆ—è¡¨ï¼Œå¯ä»¥æ„å»ºå‡ºä¸€ä¸ªæ— å‘ï¼ˆæ— æƒï¼‰å›¾ï¼›



![image.png](https://pic.leetcode-cn.com/ec8f7e4f40134b932a9ff2e306d885e427bd8ee912801361849d92ddae6226f3-image.png)

**image.png**



- å¦‚æœä¸€å¼€å§‹å°±æ„å»ºå›¾ï¼Œæ¯ä¸€ä¸ªå•è¯éƒ½éœ€è¦å’Œé™¤å®ƒä»¥å¤–çš„å¦å¤–çš„å•è¯è¿›è¡Œæ¯”è¾ƒï¼Œå¤æ‚åº¦æ˜¯ ğ‘‚(ğ‘wordLen)O(NwordLen)ï¼Œè¿™é‡Œ ğ‘N æ˜¯å•è¯åˆ—è¡¨çš„é•¿åº¦ï¼›
- ä¸ºæ­¤ï¼Œæˆ‘ä»¬åœ¨éå†ä¸€å¼€å§‹ï¼ŒæŠŠæ‰€æœ‰çš„å•è¯åˆ—è¡¨æ”¾è¿›ä¸€ä¸ªå“ˆå¸Œè¡¨ä¸­ï¼Œç„¶ååœ¨éå†çš„æ—¶å€™æ„å»ºå›¾ï¼Œæ¯ä¸€æ¬¡å¾—åˆ°åœ¨å•è¯åˆ—è¡¨é‡Œå¯ä»¥è½¬æ¢çš„å•è¯ï¼Œå¤æ‚åº¦æ˜¯ ğ‘‚(26Ã—wordLen)O(26Ã—wordLen)ï¼Œå€ŸåŠ©å“ˆå¸Œè¡¨ï¼Œæ‰¾åˆ°é‚»å±…ä¸ ğ‘N æ— å…³ï¼›
- ä½¿ç”¨ BFS è¿›è¡Œéå†ï¼Œéœ€è¦çš„è¾…åŠ©æ•°æ®ç»“æ„æ˜¯ï¼š
  - é˜Ÿåˆ—ï¼›
  - `visited` é›†åˆã€‚è¯´æ˜ï¼šå¯ä»¥ç›´æ¥åœ¨ `wordSet` (ç”± `wordList` æ”¾è¿›é›†åˆä¸­å¾—åˆ°)é‡Œåšåˆ é™¤ã€‚ä½†æ›´å¥½çš„åšæ³•æ˜¯æ–°å¼€ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œéå†è¿‡çš„å­—ç¬¦ä¸²æ”¾è¿›å“ˆå¸Œè¡¨é‡Œã€‚è¿™ç§åšæ³•å…·æœ‰æ™®éæ„ä¹‰ã€‚ç»å¤§å¤šæ•°åœ¨çº¿æµ‹è¯„ç³»ç»Ÿå’Œåº”ç”¨åœºæ™¯éƒ½ä¸ä¼šåœ¨æ„ç©ºé—´å¼€é”€ã€‚

Java ä»£ç ï¼š

**å‚è€ƒä»£ç  1**ï¼š

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;

public class Solution {

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        // å…ˆå°† wordList æ”¾åˆ°å“ˆå¸Œè¡¨é‡Œï¼Œä¾¿äºåˆ¤æ–­æŸä¸ªå•è¯æ˜¯å¦åœ¨ wordList é‡Œ
        Set<String> wordSet = new HashSet<>(wordList);
        if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
            return 0;
        }
        wordSet.remove(beginWord);

        // å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†ï¼Œå¿…é¡»ä½¿ç”¨çš„é˜Ÿåˆ—å’Œè¡¨ç¤ºæ˜¯å¦è®¿é—®è¿‡çš„ visited ï¼ˆæ•°ç»„ï¼Œå“ˆå¸Œè¡¨ï¼‰
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);

        Set<String> visited = new HashSet<>();
        visited.add(beginWord);

        int wordLen = beginWord.length();
        // åŒ…å«èµ·ç‚¹ï¼Œå› æ­¤åˆå§‹åŒ–çš„æ—¶å€™æ­¥æ•°ä¸º 1
        int step = 1;
        while (!queue.isEmpty()) {

            int currentSize = queue.size();
            for (int i = 0; i < currentSize; i++) {
                // ä¾æ¬¡éå†å½“å‰é˜Ÿåˆ—ä¸­çš„å•è¯
                String word = queue.poll();
                char[] charArray = word.toCharArray();

                // ä¿®æ”¹æ¯ä¸€ä¸ªå­—ç¬¦
                for (int j = 0; j < wordLen; j++) {
                    // ä¸€è½®ä»¥ååº”è¯¥é‡ç½®ï¼Œå¦åˆ™ç»“æœä¸æ­£ç¡®
                    char originChar = charArray[j];

                    for (char k = 'a'; k <= 'z'; k++) {
                        if (k == originChar) {
                            continue;
                        }

                        charArray[j] = k;
                        String nextWord = String.valueOf(charArray);

                        if (wordSet.contains(nextWord)) {
                            if (nextWord.equals(endWord)) {
                                return step + 1;
                            }

                            if (!visited.contains(nextWord)) {
                                queue.add(nextWord);
                                // æ³¨æ„ï¼šæ·»åŠ åˆ°é˜Ÿåˆ—ä»¥åï¼Œå¿…é¡»é©¬ä¸Šæ ‡è®°ä¸ºå·²ç»è®¿é—®
                                visited.add(nextWord);
                            }
                        }
                    }
                    // æ¢å¤
                    charArray[j] = originChar;
                }
            }
            step++;
        }
        return 0;
    }

    public static void main(String[] args) {
        String beginWord = "hit";
        String endWord = "cog";
        List<String> wordList = new ArrayList<>();
        String[] wordListArray = new String[]{"hot", "dot", "dog", "lot", "log", "cog"};
        Collections.addAll(wordList, wordListArray);
        Solution solution = new Solution();
        int res = solution.ladderLength(beginWord, endWord, wordList);
        System.out.println(res);
    }
}
```

Python ä»£ç ï¼š

```python
from typing import List
from collections import deque


class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        word_set = set(wordList)
        if len(word_set) == 0 or endWord not in word_set:
            return 0

        if beginWord in word_set:
            word_set.remove(beginWord)

        queue = deque()
        queue.append(beginWord)

        visited = set(beginWord)
        visited.add(beginWord)

        word_len = len(beginWord)
        step = 1
        while queue:
            current_size = len(queue)
            for i in range(current_size):
                word = queue.popleft()

                word_list = list(word)
                for j in range(word_len):
                    origin_char = word_list[j]

                    for k in range(26):
                        word_list[j] = chr(ord('a') + k)
                        next_word = ''.join(word_list)
                        if next_word in word_set:
                            if next_word == endWord:
                                return step + 1
                            if next_word not in visited:
                                queue.append(next_word)
                                word_set.remove(next_word)
                    word_list[j] = origin_char
            step += 1
        return 0


if __name__ == '__main__':
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot", "dot", "dog", "lot", "log", "cog"]
    solution = Solution()
    res = solution.ladderLength(beginWord, endWord, wordList)
    print(res)
```

### æ–¹æ³•äºŒï¼šåŒå‘ BFS

- å·²çŸ¥ç›®æ ‡é¡¶ç‚¹çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥åˆ†åˆ«ä»èµ·ç‚¹å’Œç›®æ ‡é¡¶ç‚¹ï¼ˆç»ˆç‚¹ï¼‰æ‰§è¡Œå¹¿åº¦ä¼˜å…ˆéå†ï¼Œç›´åˆ°éå†çš„éƒ¨åˆ†æœ‰äº¤é›†ã€‚è¿™ç§æ–¹å¼æœç´¢çš„å•è¯æ•°é‡ä¼šæ›´å°ä¸€äº›ï¼›
- æ›´åˆç†çš„åšæ³•æ˜¯ï¼Œ**æ¯æ¬¡ä»å•è¯æ•°é‡å°çš„é›†åˆå¼€å§‹æ‰©æ•£**ï¼›
- è¿™é‡Œ `beginVisited` å’Œ `endVisited` äº¤æ›¿ä½¿ç”¨ï¼Œç­‰ä»·äºå•å‘ BFS é‡Œä½¿ç”¨é˜Ÿåˆ—ï¼Œæ¯æ¬¡æ‰©æ•£éƒ½è¦åŠ åˆ°æ€»çš„ `visited` é‡Œã€‚



![image.png](https://pic.leetcode-cn.com/38dc5897de2b554ea606a92c5eada14b0e0030195334e9fd65943ed6d0f77c1d-image.png)

**image.png**



**å‚è€ƒä»£ç  2**ï¼š

Java ä»£ç ï¼š

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Solution {

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        // å…ˆå°† wordList æ”¾åˆ°å“ˆå¸Œè¡¨é‡Œï¼Œä¾¿äºåˆ¤æ–­æŸä¸ªå•è¯æ˜¯å¦åœ¨ wordList é‡Œ
        Set<String> wordSet = new HashSet<>(wordList);
        if (wordSet.size() == 0 || !wordSet.contains(endWord)) {
            return 0;
        }

        // æ ‡å‡†å†™æ³•ï¼Œæ€»çš„ visited æ•°ç»„
        Set<String> visited = new HashSet<>();

        // åˆ†åˆ«ç”¨å·¦è¾¹å’Œå³è¾¹æ‰©æ•£çš„å“ˆå¸Œè¡¨ä»£æ›¿å•å‘ BFS é‡Œçš„é˜Ÿåˆ—
        Set<String> beginVisited = new HashSet<>();
        beginVisited.add(beginWord);

        Set<String> endVisited = new HashSet<>();
        endVisited.add(endWord);

        int len = beginWord.length();
        int step = 1;
        // ç®€åŒ–æˆ while (!beginVisited.isEmpty()) äº¦å¯ 
        while (!beginVisited.isEmpty() && !endVisited.isEmpty()) {
            // æ‰“å¼€ä»¥æ–¹ä¾¿è°ƒè¯•
            // System.out.println("beginVisited => " + beginVisited);
            // System.out.println("  endVisited => " + endVisited + "\n");

            // ä¼˜å…ˆé€‰æ‹©å°çš„å“ˆå¸Œè¡¨è¿›è¡Œæ‰©æ•£ï¼Œè€ƒè™‘åˆ°çš„æƒ…å†µæ›´å°‘
            if (beginVisited.size() > endVisited.size()) {
                Set<String> temp = beginVisited;
                beginVisited = endVisited;
                endVisited = temp;
            }

            // é€»è¾‘åˆ°è¿™é‡Œï¼Œä¿è¯ beginVisited æ˜¯ç›¸å¯¹è¾ƒå°çš„é›†åˆ
            // nextLevelVisited åœ¨æ‰©æ•£å®Œæˆä»¥åï¼Œä¼šæˆä¸ºæ–°çš„ beginVisited
            Set<String> nextLevelVisited = new HashSet<>();
            for (String word : beginVisited) {
                char[] charArray = word.toCharArray();
                for (int i = 0; i < len; i++) {
                    char currentChar = charArray[i];
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (charArray[i] == c) {
                            continue;
                        }
                        charArray[i] = c;
                        String nextWord = String.valueOf(charArray);
                        if (wordSet.contains(nextWord)) {
                            if (endVisited.contains(nextWord)) {
                                return step + 1;
                            }
                            if (!visited.contains(nextWord)) {
                                nextLevelVisited.add(nextWord);
                                visited.add(nextWord);
                            }
                        }
                    }
                    // æ¢å¤ï¼Œä¸‹æ¬¡å†ç”¨
                    charArray[i] = currentChar;
                }
            }

            // è¿™ä¸€è¡Œä»£è¡¨è¡¨ç¤ºä» begin è¿™ä¸€ä¾§å‘å¤–æ‰©æ•£äº†ä¸€å±‚
            beginVisited = nextLevelVisited;
            step++;
        }
        return 0;
    }

    public static void main(String[] args) {
        List<String> wordList = new ArrayList<>();
        String[] words = {"hot", "dot", "dog", "lot", "log", "cog"};
        Collections.addAll(wordList, words);

        Solution solution = new Solution();
        String beginWord = "hit";
        String endWord = "cog";
        int ladderLength = solution.ladderLength(beginWord, endWord, wordList);
        System.out.println(String.format("ä» %s åˆ° %s çš„æœ€çŸ­è½¬æ¢åºåˆ—çš„é•¿åº¦ï¼š%dã€‚", beginWord, endWord, ladderLength));
    }
}
```

Python ä»£ç ï¼š

```python
from typing import List
from collections import deque


class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        word_set = set(wordList)
        if len(word_set) == 0 or endWord not in word_set:
            return 0

        if beginWord in word_set:
            word_set.remove(beginWord)

        visited = set()
        visited.add(beginWord)
        visited.add(endWord)

        begin_visited = set()
        begin_visited.add(beginWord)

        end_visited = set()
        end_visited.add(endWord)

        word_len = len(beginWord)
        step = 1
        # ç®€åŒ–æˆ while begin_visited äº¦å¯
        while begin_visited and end_visited:
            # æ‰“å¼€å¸®åŠ©è°ƒè¯•
            # print(begin_visited)
            # print(end_visited)

            if len(begin_visited) > len(end_visited):
                begin_visited, end_visited = end_visited, begin_visited

            next_level_visited = set()
            for word in begin_visited:
                word_list = list(word)

                for j in range(word_len):
                    origin_char = word_list[j]
                    for k in range(26):
                        word_list[j] = chr(ord('a') + k)
                        next_word = ''.join(word_list)
                        if next_word in word_set:
                            if next_word in end_visited:
                                return step + 1
                            if next_word not in visited:
                                next_level_visited.add(next_word)
                                visited.add(next_word)
                    word_list[j] = origin_char
            begin_visited = next_level_visited
            step += 1
        return 0


if __name__ == '__main__':
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot", "dot", "dog", "lot", "log", "cog"]

    solution = Solution()
    res = solution.ladderLength(beginWord, endWord, wordList)
    print(res)
```

ï¼ˆæœ¬èŠ‚å®Œï¼‰